/*
Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license ( the "Software" ) to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:
The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module derelict.cuda.driverapi;

/**
 * CUDA Driver API
 * Translation of cuda.h
 */

// Current API version supported by DerelictCUDA is 10.0
enum CUDA_VERSION = 10000;


import derelict.util.loader;

private
{
  import derelict.util.system;

  static if(Derelict_OS_Windows)
    enum libNames = "nvcuda.dll";
  else static if (Derelict_OS_Mac)
    enum libNames = "libcuda.dylib";
  else static if (Derelict_OS_Linux)
    enum libNames = "libcuda.so";
  else
    static assert(0, "Need to implement CUDA libNames for this operating system.");
}

alias cuuint32_t = uint;
alias cuuint64_t = ulong;

alias CUdeviceptr = size_t;

alias CUdevice = int;
alias CUcontext = void*;
alias CUmodule = void*;
alias CUfunction = void*;
alias CUarray = void*;
alias CUmipmappedArray = void*;
alias CUtexref = void*;
alias CUsurfref = void*;
alias CUevent = void*;
alias CUstream = void*;
alias CUgraphicsResource = void*;
alias CUtexObject = ulong;
alias CUsurfObject = ulong;
alias CUexternalMemory = void*;
alias CUexternalSemaphore = void*;
alias CUgraph = void*;
alias CUgraphNode = void*;
alias CUgraphExec = void*;

struct CUuuid
{
    char[16] bytes;
}

/**
 * CUDA IPC handle size
 */
enum CU_IPC_HANDLE_SIZE = 64;

/**
 * CUDA IPC event handle
 */
struct CUipcEventHandle
{
    char[CU_IPC_HANDLE_SIZE] reserved;
}

/**
 * CUDA IPC mem handle
 */
struct CUipcMemHandle
{
    char[CU_IPC_HANDLE_SIZE] reserved;
}

/**
 * CUDA Ipc Mem Flags
 */
alias CUipcMem_flags = int;
enum : CUipcMem_flags
{
    CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = 0x1
}

/**
 * CUDA Mem Attach Flags
 */
alias CUmemAttach_flags = int;
enum : CUmemAttach_flags
{
    CU_MEM_ATTACH_GLOBAL = 0x1,
    CU_MEM_ATTACH_HOST   = 0x2,
    CU_MEM_ATTACH_SINGLE = 0x4
}

/**
 * Context creation flags
 */
alias CUctx_flags = int;
enum : CUctx_flags
{
    CU_CTX_SCHED_AUTO          = 0x00,
    CU_CTX_SCHED_SPIN          = 0x01,
    CU_CTX_SCHED_YIELD         = 0x02,
    CU_CTX_SCHED_BLOCKING_SYNC = 0x04,
    CU_CTX_BLOCKING_SYNC       = 0x04,

    CU_CTX_SCHED_MASK          = 0x07,
    CU_CTX_MAP_HOST            = 0x08,
    CU_CTX_LMEM_RESIZE_TO_MAX  = 0x10,
    CU_CTX_FLAGS_MASK          = 0x1f
}

/**
 * Stream creation flags
 */
alias CUstream_flags = int;
enum : CUstream_flags
{
    CU_STREAM_DEFAULT      = 0x0,
    CU_STREAM_NON_BLOCKING = 0x1
}
/**
 * Flags for ::cuStreamWaitValue32 and ::cuStreamWaitValue64
 */
alias CUstreamWaitValue_flags = int;
enum : CUstreamWaitValue_flags {
  CU_STREAM_WAIT_VALUE_GEQ   = 0x0,   /**< Wait until (int32_t)(*addr - value) >= 0 (or int64_t for 64 bit
                                           values). Note this is a cyclic comparison which ignores wraparound.
                                           (Default behavior.) */
  CU_STREAM_WAIT_VALUE_EQ    = 0x1,   /**< Wait until *addr == value. */
  CU_STREAM_WAIT_VALUE_AND   = 0x2,   /**< Wait until (*addr & value) != 0. */
  CU_STREAM_WAIT_VALUE_NOR   = 0x3,   /**< Wait until ~(*addr | value) != 0. Support for this operation can be
                                           queried with ::cuDeviceGetAttribute() and
                                           ::CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR.*/
  CU_STREAM_WAIT_VALUE_FLUSH = 1<<30  /**< Follow the wait operation with a flush of outstanding remote writes. This
                                           means that, if a remote write operation is guaranteed to have reached the
                                           device before the wait can be satisfied, that write is guaranteed to be
                                           visible to downstream device work. The device is permitted to reorder
                                           remote writes internally. For example, this flag would be required if
                                           two remote writes arrive in a defined order, the wait is satisfied by the
                                           second write, and downstream work needs to observe the first write.
                                           Support for this operation is restricted to selected platforms and can be
                                           queried with ::CU_DEVICE_ATTRIBUTE_CAN_USE_WAIT_VALUE_FLUSH.*/
}


/**
 * Flags for ::cuStreamWriteValue32
 */
alias CUstreamWriteValue_flags = int;
enum : CUstreamWriteValue_flags {
  CU_STREAM_WRITE_VALUE_DEFAULT           = 0x0, /**< Default behavior */
  CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER = 0x1  /**< Permits the write to be reordered with writes which were issued
                                                      before it, as a performance optimization. Normally,
                                                      ::cuStreamWriteValue32 will provide a memory fence before the
                                                      write, which has similar semantics to
                                                      __threadfence_system() but is scoped to the stream
                                                      rather than a CUDA thread. */
}

/**
 * Operations for ::cuStreamBatchMemOp
 */
alias CUstreamBatchMemOpType = int;
enum : CUstreamBatchMemOpType {
  CU_STREAM_MEM_OP_WAIT_VALUE_32  = 1,     /**< Represents a ::cuStreamWaitValue32 operation */
  CU_STREAM_MEM_OP_WRITE_VALUE_32 = 2,     /**< Represents a ::cuStreamWriteValue32 operation */
  CU_STREAM_MEM_OP_WAIT_VALUE_64  = 4,     /**< Represents a ::cuStreamWaitValue64 operation */
  CU_STREAM_MEM_OP_WRITE_VALUE_64 = 5,     /**< Represents a ::cuStreamWriteValue64 operation */
  CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES = 3 /**< This has the same effect as ::CU_STREAM_WAIT_VALUE_FLUSH, but as a
                                                  standalone operation. */
}

/**
 * Per-operation parameters for ::cuStreamBatchMemOp
 */
union CUstreamBatchMemOpParams {
  CUstreamBatchMemOpType operation;
  struct CUstreamMemOpWaitValueParams_st {
    CUstreamBatchMemOpType operation;
    CUdeviceptr address;
    union {
        cuuint32_t value;
        cuuint64_t value64;
    };
    uint flags;
    CUdeviceptr _alias; /**< For driver internal use. Initial value is unimportant. */
  }
  CUstreamMemOpWaitValueParams_st waitValue;
  struct CUstreamMemOpWriteValueParams_st {
    CUstreamBatchMemOpType operation;
    CUdeviceptr address;
    union {
        cuuint32_t value;
        cuuint64_t value64;
    };
    uint flags;
    CUdeviceptr _alias; /**< For driver internal use. Initial value is unimportant. */
  }
  CUstreamMemOpWriteValueParams_st writeValue;
  struct CUstreamMemOpFlushRemoteWritesParams_st {
    CUstreamBatchMemOpType operation;
    uint flags;
  }
  CUstreamMemOpFlushRemoteWritesParams_st flushRemoteWrites;
  cuuint64_t[6] pad;
}


/**
 * Occupancy calculator flag
 */
alias CUoccupancy_flags = int;
enum : CUoccupancy_flags {
  CU_OCCUPANCY_DEFAULT                  = 0x0, /**< Default behavior */
  CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE = 0x1  /**< Assume global caching is enabled and cannot be automatically turned off */
}

/**
 * Event creation flags
 */
alias CUevent_flags = int;
enum : CUevent_flags
{
  CU_EVENT_DEFAULT        = 0x0,
  CU_EVENT_BLOCKING_SYNC  = 0x1,
  CU_EVENT_DISABLE_TIMING = 0x2,
  CU_EVENT_INTERPROCESS   = 0x4
}

/**
 * Array formats
 */
alias CUarray_format = int;
enum : CUarray_format
{
  CU_AD_FORMAT_UNSIGNED_INT8  = 0x01,
  CU_AD_FORMAT_UNSIGNED_INT16 = 0x02,
  CU_AD_FORMAT_UNSIGNED_INT32 = 0x03,
  CU_AD_FORMAT_SIGNED_INT8    = 0x08,
  CU_AD_FORMAT_SIGNED_INT16   = 0x09,
  CU_AD_FORMAT_SIGNED_INT32   = 0x0a,
  CU_AD_FORMAT_HALF           = 0x10,
  CU_AD_FORMAT_FLOAT          = 0x20
}

/**
 * Texture reference addressing modes
 */
alias CUaddress_mode = int;
enum : CUaddress_mode
{
  CU_TR_ADDRESS_MODE_WRAP   = 0,
  CU_TR_ADDRESS_MODE_CLAMP  = 1,
  CU_TR_ADDRESS_MODE_MIRROR = 2,
  CU_TR_ADDRESS_MODE_BORDER = 3
}

/**
 * Texture reference filtering modes
 */
alias CUfilter_mode = int;
enum : CUfilter_mode
{
  CU_TR_FILTER_MODE_POINT  = 0,
  CU_TR_FILTER_MODE_LINEAR = 1
}

/**
 * Device properties
 */
alias CUdevice_attribute = int;
enum : CUdevice_attribute
{
  CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 1,              /**< Maximum number of threads per block */
  CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X = 2,                    /**< Maximum block dimension X */
  CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y = 3,                    /**< Maximum block dimension Y */
  CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z = 4,                    /**< Maximum block dimension Z */
  CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X = 5,                     /**< Maximum grid dimension X */
  CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y = 6,                     /**< Maximum grid dimension Y */
  CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z = 7,                     /**< Maximum grid dimension Z */
  CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK = 8,        /**< Maximum shared memory available per block in bytes */
  CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK = 8,            /**< Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK */
  CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY = 9,              /**< Memory available on device for __constant__ variables in a CUDA C kernel in bytes */
  CU_DEVICE_ATTRIBUTE_WARP_SIZE = 10,                         /**< Warp size in threads */
  CU_DEVICE_ATTRIBUTE_MAX_PITCH = 11,                         /**< Maximum pitch in bytes allowed by memory copies */
  CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK = 12,           /**< Maximum number of 32-bit registers available per block */
  CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK = 12,               /**< Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK */
  CU_DEVICE_ATTRIBUTE_CLOCK_RATE = 13,                        /**< Typical clock frequency in kilohertz */
  CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT = 14,                 /**< Alignment requirement for textures */
  CU_DEVICE_ATTRIBUTE_GPU_OVERLAP = 15,                       /**< Device can possibly copy memory and execute a kernel concurrently. Deprecated. Use instead CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT. */
  CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT = 16,              /**< Number of multiprocessors on device */
  CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT = 17,               /**< Specifies whether there is a run time limit on kernels */
  CU_DEVICE_ATTRIBUTE_INTEGRATED = 18,                        /**< Device is integrated with host memory */
  CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY = 19,               /**< Device can map host memory into CUDA address space */
  CU_DEVICE_ATTRIBUTE_COMPUTE_MODE = 20,                      /**< Compute mode (See ::CUcomputemode for details) */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH = 21,           /**< Maximum 1D texture width */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH = 22,           /**< Maximum 2D texture width */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT = 23,          /**< Maximum 2D texture height */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH = 24,           /**< Maximum 3D texture width */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT = 25,          /**< Maximum 3D texture height */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH = 26,           /**< Maximum 3D texture depth */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH = 27,   /**< Maximum 2D layered texture width */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT = 28,  /**< Maximum 2D layered texture height */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS = 29,  /**< Maximum layers in a 2D layered texture */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH = 27,     /**< Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT = 28,    /**< Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES = 29, /**< Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS */
  CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT = 30,                 /**< Alignment requirement for surfaces */
  CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = 31,                /**< Device can possibly execute multiple kernels concurrently */
  CU_DEVICE_ATTRIBUTE_ECC_ENABLED = 32,                       /**< Device has ECC support enabled */
  CU_DEVICE_ATTRIBUTE_PCI_BUS_ID = 33,                        /**< PCI bus ID of the device */
  CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID = 34,                     /**< PCI device ID of the device */
  CU_DEVICE_ATTRIBUTE_TCC_DRIVER = 35,                        /**< Device is using TCC driver model */
  CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE = 36,                 /**< Peak memory clock frequency in kilohertz */
  CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH = 37,           /**< Global memory bus width in bits */
  CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE = 38,                     /**< Size of L2 cache in bytes */
  CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR = 39,    /**< Maximum resident threads per multiprocessor */
  CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = 40,                /**< Number of asynchronous engines */
  CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = 41,                /**< Device shares a unified address space with the host */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH = 42,   /**< Maximum 1D layered texture width */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS = 43,  /**< Maximum layers in a 1D layered texture */
  CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER = 44,                  /**< Deprecated, do not use. */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH = 45,    /**< Maximum 2D texture width if CUDA_ARRAY3D_TEXTURE_GATHER is set */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT = 46,   /**< Maximum 2D texture height if CUDA_ARRAY3D_TEXTURE_GATHER is set */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE = 47, /**< Alternate maximum 3D texture width */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE = 48,/**< Alternate maximum 3D texture height */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE = 49, /**< Alternate maximum 3D texture depth */
  CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID = 50,                     /**< PCI domain ID of the device */
  CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT = 51,           /**< Pitch alignment requirement for textures */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH = 52,      /**< Maximum cubemap texture width/height */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH = 53,  /**< Maximum cubemap layered texture width/height */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS = 54, /**< Maximum layers in a cubemap layered texture */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH = 55,           /**< Maximum 1D surface width */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH = 56,           /**< Maximum 2D surface width */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT = 57,          /**< Maximum 2D surface height */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH = 58,           /**< Maximum 3D surface width */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT = 59,          /**< Maximum 3D surface height */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH = 60,           /**< Maximum 3D surface depth */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH = 61,   /**< Maximum 1D layered surface width */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS = 62,  /**< Maximum layers in a 1D layered surface */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH = 63,   /**< Maximum 2D layered surface width */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT = 64,  /**< Maximum 2D layered surface height */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS = 65,  /**< Maximum layers in a 2D layered surface */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH = 66,      /**< Maximum cubemap surface width */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH = 67,  /**< Maximum cubemap layered surface width */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS = 68, /**< Maximum layers in a cubemap layered surface */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH = 69,    /**< Maximum 1D linear texture width */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH = 70,    /**< Maximum 2D linear texture width */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT = 71,   /**< Maximum 2D linear texture height */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH = 72,    /**< Maximum 2D linear texture pitch in bytes */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH = 73, /**< Maximum mipmapped 2D texture width */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT = 74,/**< Maximum mipmapped 2D texture height */
  CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR = 75,          /**< Major compute capability version number */
  CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR = 76,          /**< Minor compute capability version number */
  CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH = 77, /**< Maximum mipmapped 1D texture width */
  CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED = 78,       /**< Device supports stream priorities */
  CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED = 79,         /**< Device supports caching globals in L1 */
  CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED = 80,          /**< Device supports caching locals in L1 */
  CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR = 81,  /**< Maximum shared memory available per multiprocessor in bytes */
  CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR = 82,  /**< Maximum number of 32-bit registers available per multiprocessor */
  CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY = 83,                    /**< Device can allocate managed memory on this system */
  CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD = 84,                    /**< Device is on a multi-GPU board */
  CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID = 85,           /**< Unique id for a group of devices on the same multi-GPU board */
  CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED = 86,       /**< Link between the device and the host supports native atomic operations (this is a placeholder attribute, and is not supported on any current hardware)*/
  CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO = 87,  /**< Ratio of single precision performance (in floating-point operations per second) to double precision performance */
  CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS = 88,            /**< Device supports coherently accessing pageable memory without calling cudaHostRegister on it */
  CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS = 89,         /**< Device can coherently access managed memory concurrently with the CPU */
  CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED = 90,      /**< Device supports compute preemption. */
  CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM = 91, /**< Device can access host registered memory at the same virtual address as the CPU */
  CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS = 92,            /**< ::cuStreamBatchMemOp and related APIs are supported. */
  CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS = 93,     /**< 64-bit operations are supported in ::cuStreamBatchMemOp and related APIs. */
  CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR = 94,     /**< ::CU_STREAM_WAIT_VALUE_NOR is supported. */
  CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH = 95,                /**< Device supports launching cooperative kernels via ::cuLaunchCooperativeKernel */
  CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH = 96,   /**< Device can participate in cooperative kernels launched via ::cuLaunchCooperativeKernelMultiDevice */
  CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN = 97, /**< Maximum optin shared memory per block */
  CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES = 98,           /**< Both the ::CU_STREAM_WAIT_VALUE_FLUSH flag and the ::CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES MemOp are supported on the device. See \ref CUDA_MEMOP for additional details. */
  CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED = 99,           /**< Device supports host memory registration via ::cudaHostRegister. */
  CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES = 100, /**< Device accesses pageable memory via the host's page tables. */
  CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST = 101, /**< The host can directly access managed memory on the device without migration. */
  CU_DEVICE_ATTRIBUTE_MAX
}

/**
 * Legacy device properties
 */
struct CUdevprop
{
  int maxThreadsPerBlock;
  int[3] maxThreadsDim;
  int[3] maxGridSize;
  int sharedMemPerBlock;
  int totalConstantMemory;
  int SIMDWidth;
  int memPitch;
  int regsPerBlock;
  int clockRate;
  int textureAlign;
}

/**
 * Pointer information
 */
alias CUpointer_attribute = int;
enum : CUpointer_attribute
{
  CU_POINTER_ATTRIBUTE_CONTEXT = 1,
  CU_POINTER_ATTRIBUTE_MEMORY_TYPE = 2,
  CU_POINTER_ATTRIBUTE_DEVICE_POINTER = 3,
  CU_POINTER_ATTRIBUTE_HOST_POINTER = 4,
  CU_POINTER_ATTRIBUTE_P2P_TOKENS = 5,
  CU_POINTER_ATTRIBUTE_SYNC_MEMOPS = 6,
  CU_POINTER_ATTRIBUTE_BUFFER_ID = 7,
  CU_POINTER_ATTRIBUTE_IS_MANAGED = 8,
  CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL = 9  /**< A device ordinal of a device on which a pointer was allocated or registered */
}

/**
 * Function properties
 */
alias CUfunction_attribute = int;
enum : CUfunction_attribute
{
  /**
   * The maximum number of threads per block, beyond which a launch of the
   * function would fail. This number depends on both the function and the
   * device on which the function is currently loaded.
   */
  CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 0,

  /**
   * The size in bytes of statically-allocated shared memory required by
   * this function. This does not include dynamically-allocated shared
   * memory requested by the user at runtime.
   */
  CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = 1,

  /**
   * The size in bytes of user-allocated constant memory required by this
   * function.
   */
  CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = 2,

  /**
   * The size in bytes of local memory used by each thread of this function.
   */
  CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = 3,

  /**
   * The number of registers used by each thread of this function.
   */
  CU_FUNC_ATTRIBUTE_NUM_REGS = 4,

  /**
   * The PTX virtual architecture version for which the function was
   * compiled. This value is the major PTX version * 10 + the minor PTX
   * version, so a PTX version 1.3 function would return the value 13.
   * Note that this may return the undefined value of 0 for cubins
   * compiled prior to CUDA 3.0.
   */
  CU_FUNC_ATTRIBUTE_PTX_VERSION = 5,

  /**
   * The binary architecture version for which the function was compiled.
   * This value is the major binary version * 10 + the minor binary version,
   * so a binary version 1.3 function would return the value 13. Note that
   * this will return a value of 10 for legacy cubins that do not have a
   * properly-encoded binary architecture version.
   */
  CU_FUNC_ATTRIBUTE_BINARY_VERSION = 6,

  /**
   * The attribute to indicate whether the function has been compiled with
   * user specified option "-Xptxas --dlcm=ca" set .
   */
  CU_FUNC_ATTRIBUTE_CACHE_MODE_CA = 7,

  /**
   * The maximum size in bytes of dynamically-allocated shared memory that can be used by
   * this function. If the user-specified dynamic shared memory size is larger than this
   * value, the launch will fail.
   */
  CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = 8,

  /**
   * On devices where the L1 cache and shared memory use the same hardware resources,
   * this sets the shared memory carveout preference, in percent of the total resources.
   * This is only a hint, and the driver can choose a different ratio if required to execute the function.
   */
  CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = 9,

  CU_FUNC_ATTRIBUTE_MAX
}

/**
 * Function cache configurations
 */
alias CUfunc_cache = int;
enum : CUfunc_cache
{
  CU_FUNC_CACHE_PREFER_NONE    = 0x00,
  CU_FUNC_CACHE_PREFER_SHARED  = 0x01,
  CU_FUNC_CACHE_PREFER_L1      = 0x02,
  CU_FUNC_CACHE_PREFER_EQUAL   = 0x03
}

/**
 * Shared memory configurations
 */
alias CUsharedconfig = int;
enum : CUsharedconfig
{
  CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE    = 0x00,
  CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE  = 0x01,
  CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE = 0x02
}

/**
 * Shared memory carveout configurations
 */
alias CUshared_carveout = int;
enum : CUshared_carveout {
  CU_SHAREDMEM_CARVEOUT_DEFAULT       = -1,  /** < no preference for shared memory or L1 (default) */
  CU_SHAREDMEM_CARVEOUT_MAX_SHARED    = 100, /** < prefer maximum available shared memory, minimum L1 cache */
  CU_SHAREDMEM_CARVEOUT_MAX_L1        = 0    /** < prefer maximum available L1 cache, minimum shared memory */
}

/**
 * Memory types
 */
alias CUmemorytype = int;
enum : CUmemorytype
{
  CU_MEMORYTYPE_HOST    = 0x01,
  CU_MEMORYTYPE_DEVICE  = 0x02,
  CU_MEMORYTYPE_ARRAY   = 0x03,
  CU_MEMORYTYPE_UNIFIED = 0x04
}


/**
 * Compute Modes
 */
alias CUcomputemode = int;
enum : CUcomputemode
{
  CU_COMPUTEMODE_DEFAULT           = 0,
  CU_COMPUTEMODE_EXCLUSIVE         = 1,
  CU_COMPUTEMODE_PROHIBITED        = 2,
  CU_COMPUTEMODE_EXCLUSIVE_PROCESS = 3
}


/**
 * Memory advise values
 */
alias CUmem_advise = int;
enum : CUmem_advise {
  CU_MEM_ADVISE_SET_READ_MOSTLY          = 1, /**< Data will mostly be read and only occassionally be written to */
  CU_MEM_ADVISE_UNSET_READ_MOSTLY        = 2, /**< Undo the effect of ::CU_MEM_ADVISE_SET_READ_MOSTLY */
  CU_MEM_ADVISE_SET_PREFERRED_LOCATION   = 3, /**< Set the preferred location for the data as the specified device */
  CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION = 4, /**< Clear the preferred location for the data */
  CU_MEM_ADVISE_SET_ACCESSED_BY          = 5, /**< Data will be accessed by the specified device, so prevent page faults as much as possible */
  CU_MEM_ADVISE_UNSET_ACCESSED_BY        = 6  /**< Let the Unified Memory subsystem decide on the page faulting policy for the specified device */
}

alias CUmem_range_attribute = int;
enum : CUmem_range_attribute {
  CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY            = 1, /**< Whether the range will mostly be read and only occassionally be written to */
  CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION     = 2, /**< The preferred location of the range */
  CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY            = 3, /**< Memory range has ::CU_MEM_ADVISE_SET_ACCESSED_BY set for specified device */
  CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION = 4  /**< The last location to which the range was prefetched */
}

alias CUjit_option = int;
enum : CUjit_option
{
    CU_JIT_MAX_REGISTERS = 0,
    CU_JIT_THREADS_PER_BLOCK,
    CU_JIT_WALL_TIME,
    CU_JIT_INFO_LOG_BUFFER,
    CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES,
    CU_JIT_ERROR_LOG_BUFFER,
    CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES,
    CU_JIT_OPTIMIZATION_LEVEL,
    CU_JIT_TARGET_FROM_CUCONTEXT,
    CU_JIT_TARGET,
    CU_JIT_FALLBACK_STRATEGY,
    CU_JIT_GENERATE_DEBUG_INFO,
    CU_JIT_LOG_VERBOSE,
    CU_JIT_GENERATE_LINE_INFO,
    CU_JIT_CACHE_MODE,
    CU_JIT_NEW_SM3X_OPT,
    CU_JIT_FAST_COMPILE,
    CU_JIT_GLOBAL_SYMBOL_NAMES,
    CU_JIT_GLOBAL_SYMBOL_ADDRESSES,
    CU_JIT_GLOBAL_SYMBOL_COUNT,
    CU_JIT_NUM_OPTIONS
}

/**
 * Online compilation targets
 */
alias CUjit_target = int;
enum : CUjit_target
{
  CU_TARGET_COMPUTE_20 = 20,       /**< Compute device class 2.0 */
  CU_TARGET_COMPUTE_21 = 21,       /**< Compute device class 2.1 */
  CU_TARGET_COMPUTE_30 = 30,       /**< Compute device class 3.0 */
  CU_TARGET_COMPUTE_32 = 32,       /**< Compute device class 3.2 */
  CU_TARGET_COMPUTE_35 = 35,       /**< Compute device class 3.5 */
  CU_TARGET_COMPUTE_37 = 37,       /**< Compute device class 3.7 */
  CU_TARGET_COMPUTE_50 = 50,       /**< Compute device class 5.0 */
  CU_TARGET_COMPUTE_52 = 52,       /**< Compute device class 5.2 */
  CU_TARGET_COMPUTE_53 = 53,       /**< Compute device class 5.3 */
  CU_TARGET_COMPUTE_60 = 60,       /**< Compute device class 6.0.*/
  CU_TARGET_COMPUTE_61 = 61,       /**< Compute device class 6.1.*/
  CU_TARGET_COMPUTE_62 = 62,       /**< Compute device class 6.2.*/
  CU_TARGET_COMPUTE_70 = 70,       /**< Compute device class 7.0.*/

  CU_TARGET_COMPUTE_75 = 75        /**< Compute device class 7.5.*/
}

/**
 * Cubin matching fallback strategies
 */
alias CUjit_fallback = int;
enum : CUjit_fallback
{
  CU_PREFER_PTX = 0,
  CU_PREFER_BINARY
}


/**
 * Caching modes for dlcm
 */
alias CUjit_cacheMode = int;
enum : CUjit_cacheMode
{
  CU_JIT_CACHE_OPTION_NONE = 0,
  CU_JIT_CACHE_OPTION_CG,
  CU_JIT_CACHE_OPTION_CA
}

/**
 * Device code formats
 */
alias CUjitInputType = int;
enum : CUjitInputType
{
  CU_JIT_INPUT_CUBIN = 0,
  CU_JIT_INPUT_PTX,
  CU_JIT_INPUT_FATBINARY,
  CU_JIT_INPUT_OBJECT,
  CU_JIT_INPUT_LIBRARY,
  CU_JIT_NUM_INPUT_TYPES
}

alias CUlinkState = void*;

/**
 * Flags to register a graphics resource
 */
alias CUgraphicsRegisterFlags = int;
enum : CUgraphicsRegisterFlags
{
  CU_GRAPHICS_REGISTER_FLAGS_NONE           = 0x00,
  CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY      = 0x01,
  CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD  = 0x02,
  CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST   = 0x04,
  CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = 0x08
}

/**
 * Flags for mapping and unmapping interop resources
 */
alias CUgraphicsMapResourceFlags = int;
enum : CUgraphicsMapResourceFlags
{
  CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE          = 0x00,
  CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY     = 0x01,
  CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD = 0x02
}

/**
 * Array indices for cube faces
 */
alias CUarray_cubemap_face = int;
enum : CUarray_cubemap_face
{
  CU_CUBEMAP_FACE_POSITIVE_X  = 0x00,
  CU_CUBEMAP_FACE_NEGATIVE_X  = 0x01,
  CU_CUBEMAP_FACE_POSITIVE_Y  = 0x02,
  CU_CUBEMAP_FACE_NEGATIVE_Y  = 0x03,
  CU_CUBEMAP_FACE_POSITIVE_Z  = 0x04,
  CU_CUBEMAP_FACE_NEGATIVE_Z  = 0x05
}

/**
 * Limits
 */
alias CUlimit = int;
enum : CUlimit
{
  CU_LIMIT_STACK_SIZE                       = 0x00,
  CU_LIMIT_PRINTF_FIFO_SIZE                 = 0x01,
  CU_LIMIT_MALLOC_HEAP_SIZE                 = 0x02,
  CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH           = 0x03,
  CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT = 0x04,
  CU_LIMIT_MAX_L2_FETCH_GRANULARITY         = 0x05, /**< A value between 0 and 128 that indicates the maximum fetch granularity of L2 (in Bytes). This is a hint */
  CU_LIMIT_MAX
}

/**
 * Resource types
 */
alias CUresourcetype = int;
enum : CUresourcetype
{
  CU_RESOURCE_TYPE_ARRAY           = 0x00,
  CU_RESOURCE_TYPE_MIPMAPPED_ARRAY = 0x01,
  CU_RESOURCE_TYPE_LINEAR          = 0x02,
  CU_RESOURCE_TYPE_PITCH2D         = 0x03
}


//
// New for CUDA >= 10.0
//
alias CUhostFn = void function(void *userData);


/**
 * GPU kernel node parameters
 */
struct CUDA_KERNEL_NODE_PARAMS {
  CUfunction func;             /**< Kernel to launch */
  uint gridDimX;       /**< Width of grid in blocks */
  uint gridDimY;       /**< Height of grid in blocks */
  uint gridDimZ;       /**< Depth of grid in blocks */
  uint blockDimX;      /**< X dimension of each thread block */
  uint blockDimY;      /**< Y dimension of each thread block */
  uint blockDimZ;      /**< Z dimension of each thread block */
  uint sharedMemBytes; /**< Dynamic shared-memory size per thread block in bytes */
  void **kernelParams;         /**< Array of pointers to kernel parameters */
  void **extra;                /**< Extra options */
}

/**
 * Memset node parameters
 */
struct CUDA_MEMSET_NODE_PARAMS {
  CUdeviceptr dst;                        /**< Destination device pointer */
  size_t pitch;                           /**< Pitch of destination device pointer. Unused if height is 1 */
  uint value;                     /**< Value to be set */
  uint elementSize;               /**< Size of each element in bytes. Must be 1, 2, or 4. */
  size_t width;                           /**< Width in bytes, of the row */
  size_t height;                          /**< Number of rows */
}

/**
 * Host node parameters
 */
struct CUDA_HOST_NODE_PARAMS {
  CUhostFn fn;    /**< The function to call when the node executes */
  void* userData; /**< Argument to pass to the function */
}

/**
 * Graph node types
 */
alias CUgraphNodeType = int;
enum : CUgraphNodeType {
  CU_GRAPH_NODE_TYPE_KERNEL = 0, /**< GPU kernel node */
  CU_GRAPH_NODE_TYPE_MEMCPY = 1, /**< Memcpy node */
  CU_GRAPH_NODE_TYPE_MEMSET = 2, /**< Memset node */
  CU_GRAPH_NODE_TYPE_HOST   = 3, /**< Host (executable) node */
  CU_GRAPH_NODE_TYPE_GRAPH  = 4, /**< Node which executes an embedded graph */
  CU_GRAPH_NODE_TYPE_EMPTY  = 5, /**< Empty (no-op) node */
  CU_GRAPH_NODE_TYPE_COUNT
}

/**
 * Possible stream capture statuses returned by ::cuStreamIsCapturing
 */
alias CUstreamCaptureStatus = int;
enum : CUstreamCaptureStatus {
  CU_STREAM_CAPTURE_STATUS_NONE        = 0, /**< Stream is not capturing */
  CU_STREAM_CAPTURE_STATUS_ACTIVE      = 1, /**< Stream is actively capturing */
  CU_STREAM_CAPTURE_STATUS_INVALIDATED = 2  /**< Stream is part of a capture sequence that
                                                 has been invalidated, but not terminated */
}


alias CUresult = int;
enum : CUresult
{
  /**
     * The API call returned with no errors. In the case of query calls, this
     * also means that the operation being queried is complete (see
     * ::cuEventQuery() and ::cuStreamQuery()).
     */
    CUDA_SUCCESS                              = 0,

    /**
     * This indicates that one or more of the parameters passed to the API call
     * is not within an acceptable range of values.
     */
    CUDA_ERROR_INVALID_VALUE                  = 1,

    /**
     * The API call failed because it was unable to allocate enough memory to
     * perform the requested operation.
     */
    CUDA_ERROR_OUT_OF_MEMORY                  = 2,

    /**
     * This indicates that the CUDA driver has not been initialized with
     * ::cuInit() or that initialization has failed.
     */
    CUDA_ERROR_NOT_INITIALIZED                = 3,

    /**
     * This indicates that the CUDA driver is in the process of shutting down.
     */
    CUDA_ERROR_DEINITIALIZED                  = 4,

    /**
     * This indicates profiler is not initialized for this run. This can
     * happen when the application is running with external profiling tools
     * like visual profiler.
     */
    CUDA_ERROR_PROFILER_DISABLED              = 5,

    /**
     * \deprecated
     * This error return is deprecated as of CUDA 5.0. It is no longer an error
     * to attempt to enable/disable the profiling via ::cuProfilerStart or
     * ::cuProfilerStop without initialization.
     */
    CUDA_ERROR_PROFILER_NOT_INITIALIZED       = 6,

    /**
     * \deprecated
     * This error return is deprecated as of CUDA 5.0. It is no longer an error
     * to call cuProfilerStart() when profiling is already enabled.
     */
    CUDA_ERROR_PROFILER_ALREADY_STARTED       = 7,

    /**
     * \deprecated
     * This error return is deprecated as of CUDA 5.0. It is no longer an error
     * to call cuProfilerStop() when profiling is already disabled.
     */
    CUDA_ERROR_PROFILER_ALREADY_STOPPED       = 8,

    /**
     * This indicates that no CUDA-capable devices were detected by the installed
     * CUDA driver.
     */
    CUDA_ERROR_NO_DEVICE                      = 100,

    /**
     * This indicates that the device ordinal supplied by the user does not
     * correspond to a valid CUDA device.
     */
    CUDA_ERROR_INVALID_DEVICE                 = 101,


    /**
     * This indicates that the device kernel image is invalid. This can also
     * indicate an invalid CUDA module.
     */
    CUDA_ERROR_INVALID_IMAGE                  = 200,

    /**
     * This most frequently indicates that there is no context bound to the
     * current thread. This can also be returned if the context passed to an
     * API call is not a valid handle (such as a context that has had
     * ::cuCtxDestroy() invoked on it). This can also be returned if a user
     * mixes different API versions (i.e. 3010 context with 3020 API calls).
     * See ::cuCtxGetApiVersion() for more details.
     */
    CUDA_ERROR_INVALID_CONTEXT                = 201,

    /**
     * This indicated that the context being supplied as a parameter to the
     * API call was already the active context.
     * \deprecated
     * This error return is deprecated as of CUDA 3.2. It is no longer an
     * error to attempt to push the active context via ::cuCtxPushCurrent().
     */
    CUDA_ERROR_CONTEXT_ALREADY_CURRENT        = 202,

    /**
     * This indicates that a map or register operation has failed.
     */
    CUDA_ERROR_MAP_FAILED                     = 205,

    /**
     * This indicates that an unmap or unregister operation has failed.
     */
    CUDA_ERROR_UNMAP_FAILED                   = 206,

    /**
     * This indicates that the specified array is currently mapped and thus
     * cannot be destroyed.
     */
    CUDA_ERROR_ARRAY_IS_MAPPED                = 207,

    /**
     * This indicates that the resource is already mapped.
     */
    CUDA_ERROR_ALREADY_MAPPED                 = 208,

    /**
     * This indicates that there is no kernel image available that is suitable
     * for the device. This can occur when a user specifies code generation
     * options for a particular CUDA source file that do not include the
     * corresponding device configuration.
     */
    CUDA_ERROR_NO_BINARY_FOR_GPU              = 209,

    /**
     * This indicates that a resource has already been acquired.
     */
    CUDA_ERROR_ALREADY_ACQUIRED               = 210,

    /**
     * This indicates that a resource is not mapped.
     */
    CUDA_ERROR_NOT_MAPPED                     = 211,

    /**
     * This indicates that a mapped resource is not available for access as an
     * array.
     */
    CUDA_ERROR_NOT_MAPPED_AS_ARRAY            = 212,

    /**
     * This indicates that a mapped resource is not available for access as a
     * pointer.
     */
    CUDA_ERROR_NOT_MAPPED_AS_POINTER          = 213,

    /**
     * This indicates that an uncorrectable ECC error was detected during
     * execution.
     */
    CUDA_ERROR_ECC_UNCORRECTABLE              = 214,

    /**
     * This indicates that the ::CUlimit passed to the API call is not
     * supported by the active device.
     */
    CUDA_ERROR_UNSUPPORTED_LIMIT              = 215,

    /**
     * This indicates that the ::CUcontext passed to the API call can
     * only be bound to a single CPU thread at a time but is already
     * bound to a CPU thread.
     */
    CUDA_ERROR_CONTEXT_ALREADY_IN_USE         = 216,

    /**
     * This indicates that peer access is not supported across the given
     * devices.
     */
    CUDA_ERROR_PEER_ACCESS_UNSUPPORTED        = 217,

    /**
     * This indicates that a PTX JIT compilation failed.
     */
    CUDA_ERROR_INVALID_PTX                    = 218,

    /**
     * This indicates an error with OpenGL or DirectX context.
     */
    CUDA_ERROR_INVALID_GRAPHICS_CONTEXT       = 219,

    /**
    * This indicates that an uncorrectable NVLink error was detected during the
    * execution.
    */
    CUDA_ERROR_NVLINK_UNCORRECTABLE           = 220,

    /**
    * This indicates that the PTX JIT compiler library was not found.
    */
    CUDA_ERROR_JIT_COMPILER_NOT_FOUND         = 221,

    /**
     * This indicates that the device kernel source is invalid.
     */
    CUDA_ERROR_INVALID_SOURCE                 = 300,

    /**
     * This indicates that the file specified was not found.
     */
    CUDA_ERROR_FILE_NOT_FOUND                 = 301,

    /**
     * This indicates that a link to a shared object failed to resolve.
     */
    CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND = 302,

    /**
     * This indicates that initialization of a shared object failed.
     */
    CUDA_ERROR_SHARED_OBJECT_INIT_FAILED      = 303,

    /**
     * This indicates that an OS call failed.
     */
    CUDA_ERROR_OPERATING_SYSTEM               = 304,

    /**
     * This indicates that a resource handle passed to the API call was not
     * valid. Resource handles are opaque types like ::CUstream and ::CUevent.
     */
    CUDA_ERROR_INVALID_HANDLE                 = 400,

    /**
     * This indicates that a resource required by the API call is not in a
     * valid state to perform the requested operation.
     */
    CUDA_ERROR_ILLEGAL_STATE                  = 401,

    /**
     * This indicates that a named symbol was not found. Examples of symbols
     * are global/constant variable names, texture names, and surface names.
     */
    CUDA_ERROR_NOT_FOUND                      = 500,

    /**
     * This indicates that asynchronous operations issued previously have not
     * completed yet. This result is not actually an error, but must be indicated
     * differently than ::CUDA_SUCCESS (which indicates completion). Calls that
     * may return this value include ::cuEventQuery() and ::cuStreamQuery().
     */
    CUDA_ERROR_NOT_READY                      = 600,

    /**
     * While executing a kernel, the device encountered a
     * load or store instruction on an invalid memory address.
     * This leaves the process in an inconsistent state and any further CUDA work
     * will return the same error. To continue using CUDA, the process must be terminated
     * and relaunched.
     */
    CUDA_ERROR_ILLEGAL_ADDRESS                = 700,

    /**
     * This indicates that a launch did not occur because it did not have
     * appropriate resources. This error usually indicates that the user has
     * attempted to pass too many arguments to the device kernel, or the
     * kernel launch specifies too many threads for the kernel's register
     * count. Passing arguments of the wrong size (i.e. a 64-bit pointer
     * when a 32-bit int is expected) is equivalent to passing too many
     * arguments and can also result in this error.
     */
    CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES        = 701,

    /**
     * This indicates that the device kernel took too long to execute. This can
     * only occur if timeouts are enabled - see the device attribute
     * ::CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT for more information.
     * This leaves the process in an inconsistent state and any further CUDA work
     * will return the same error. To continue using CUDA, the process must be terminated
     * and relaunched.
     */
    CUDA_ERROR_LAUNCH_TIMEOUT                 = 702,

    /**
     * This error indicates a kernel launch that uses an incompatible texturing
     * mode.
     */
    CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING  = 703,

    /**
     * This error indicates that a call to ::cuCtxEnablePeerAccess() is
     * trying to re-enable peer access to a context which has already
     * had peer access to it enabled.
     */
    CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED    = 704,

    /**
     * This error indicates that ::cuCtxDisablePeerAccess() is
     * trying to disable peer access which has not been enabled yet
     * via ::cuCtxEnablePeerAccess().
     */
    CUDA_ERROR_PEER_ACCESS_NOT_ENABLED        = 705,

    /**
     * This error indicates that the primary context for the specified device
     * has already been initialized.
     */
    CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE         = 708,

    /**
     * This error indicates that the context current to the calling thread
     * has been destroyed using ::cuCtxDestroy, or is a primary context which
     * has not yet been initialized.
     */
    CUDA_ERROR_CONTEXT_IS_DESTROYED           = 709,

    /**
     * A device-side assert triggered during kernel execution. The context
     * cannot be used anymore, and must be destroyed. All existing device
     * memory allocations from this context are invalid and must be
     * reconstructed if the program is to continue using CUDA.
     */
    CUDA_ERROR_ASSERT                         = 710,

    /**
     * This error indicates that the hardware resources required to enable
     * peer access have been exhausted for one or more of the devices
     * passed to ::cuCtxEnablePeerAccess().
     */
    CUDA_ERROR_TOO_MANY_PEERS                 = 711,

    /**
     * This error indicates that the memory range passed to ::cuMemHostRegister()
     * has already been registered.
     */
    CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED = 712,

    /**
     * This error indicates that the pointer passed to ::cuMemHostUnregister()
     * does not correspond to any currently registered memory region.
     */
    CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED     = 713,

    /**
     * While executing a kernel, the device encountered a stack error.
     * This can be due to stack corruption or exceeding the stack size limit.
     * This leaves the process in an inconsistent state and any further CUDA work
     * will return the same error. To continue using CUDA, the process must be terminated
     * and relaunched.
     */
    CUDA_ERROR_HARDWARE_STACK_ERROR           = 714,

    /**
     * While executing a kernel, the device encountered an illegal instruction.
     * This leaves the process in an inconsistent state and any further CUDA work
     * will return the same error. To continue using CUDA, the process must be terminated
     * and relaunched.
     */
    CUDA_ERROR_ILLEGAL_INSTRUCTION            = 715,

    /**
     * While executing a kernel, the device encountered a load or store instruction
     * on a memory address which is not aligned.
     * This leaves the process in an inconsistent state and any further CUDA work
     * will return the same error. To continue using CUDA, the process must be terminated
     * and relaunched.
     */
    CUDA_ERROR_MISALIGNED_ADDRESS             = 716,

    /**
     * While executing a kernel, the device encountered an instruction
     * which can only operate on memory locations in certain address spaces
     * (global, shared, or local), but was supplied a memory address not
     * belonging to an allowed address space.
     * This leaves the process in an inconsistent state and any further CUDA work
     * will return the same error. To continue using CUDA, the process must be terminated
     * and relaunched.
     */
    CUDA_ERROR_INVALID_ADDRESS_SPACE          = 717,

    /**
     * While executing a kernel, the device program counter wrapped its address space.
     * This leaves the process in an inconsistent state and any further CUDA work
     * will return the same error. To continue using CUDA, the process must be terminated
     * and relaunched.
     */
    CUDA_ERROR_INVALID_PC                     = 718,

    /**
     * An exception occurred on the device while executing a kernel. Common
     * causes include dereferencing an invalid device pointer and accessing
     * out of bounds shared memory.
     * This leaves the process in an inconsistent state and any further CUDA work
     * will return the same error. To continue using CUDA, the process must be terminated
     * and relaunched.
     */
    CUDA_ERROR_LAUNCH_FAILED                  = 719,

    /**
     * This error indicates that the number of blocks launched per grid for a kernel that was
     * launched via either ::cuLaunchCooperativeKernel or ::cuLaunchCooperativeKernelMultiDevice
     * exceeds the maximum number of blocks as allowed by ::cuOccupancyMaxActiveBlocksPerMultiprocessor
     * or ::cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags times the number of multiprocessors
     * as specified by the device attribute ::CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT.
     */
    CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE   = 720,

    /**
     * This error indicates that the attempted operation is not permitted.
     */
    CUDA_ERROR_NOT_PERMITTED                  = 800,

    /**
     * This error indicates that the attempted operation is not supported
     * on the current system or device.
     */
    CUDA_ERROR_NOT_SUPPORTED                  = 801,

    /**
     * This error indicates that the system is not yet ready to start any CUDA
     * work.  To continue using CUDA, verify the system configuration is in a
     * valid state and all required driver daemons are actively running.
     */
    CUDA_ERROR_SYSTEM_NOT_READY               = 802,

    /**
     * This error indicates that the operation is not permitted when
     * the stream is capturing.
     */
    CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED     = 900,

    /**
     * This error indicates that the current capture sequence on the stream
     * has been invalidated due to a previous error.
     */
    CUDA_ERROR_STREAM_CAPTURE_INVALIDATED     = 901,

    /**
     * This error indicates that the operation would have resulted in a merge
     * of two independent capture sequences.
     */
    CUDA_ERROR_STREAM_CAPTURE_MERGE           = 902,

    /**
     * This error indicates that the capture was not initiated in this stream.
     */
    CUDA_ERROR_STREAM_CAPTURE_UNMATCHED       = 903,

    /**
     * This error indicates that the capture sequence contains a fork that was
     * not joined to the primary stream.
     */
    CUDA_ERROR_STREAM_CAPTURE_UNJOINED        = 904,

    /**
     * This error indicates that a dependency would have been created which
     * crosses the capture sequence boundary. Only implicit in-stream ordering
     * dependencies are allowed to cross the boundary.
     */
    CUDA_ERROR_STREAM_CAPTURE_ISOLATION       = 905,

    /**
     * This error indicates a disallowed implicit dependency on a current capture
     * sequence from cudaStreamLegacy.
     */
    CUDA_ERROR_STREAM_CAPTURE_IMPLICIT        = 906,

    /**
     * This error indicates that the operation is not permitted on an event which
     * was last recorded in a capturing stream.
     */
    CUDA_ERROR_CAPTURED_EVENT                 = 907,

    /**
     * This indicates that an unknown internal error has occurred.
     */
    CUDA_ERROR_UNKNOWN                        = 999
}


/**
 * P2P Attributes
 */
alias CUdevice_P2PAttribute = int;
enum : CUdevice_P2PAttribute {
  CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK                     = 0x01,  /**< A relative value indicating the performance of the link between two devices */
  CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED                     = 0x02,  /**< P2P Access is enable */
  CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED              = 0x03,  /**< Atomic operation over the link supported */
  CU_DEVICE_P2P_ATTRIBUTE_ARRAY_ACCESS_ACCESS_SUPPORTED        = 0x04,  /**< \deprecated use CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED instead */
  CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED          = 0x04   /**< Accessing CUDA arrays over the link supported */
}

extern(System) nothrow
{
    alias CUstreamCallback = void function(CUstream hStream, CUresult status, void *userData);
    alias CUoccupancyB2DSize = size_t function(int blockSize);
}

enum CU_MEMHOSTALLOC_PORTABLE        = 0x01;
enum CU_MEMHOSTALLOC_DEVICEMAP       = 0x02;
enum CU_MEMHOSTALLOC_WRITECOMBINED   = 0x04;
enum CU_MEMHOSTREGISTER_PORTABLE     = 0x01;
enum CU_MEMHOSTREGISTER_DEVICEMAP    = 0x02;
enum CU_MEMHOSTREGISTER_IOMEMORY     = 0x04;

struct CUDA_MEMCPY2D
{
    size_t srcXInBytes;
    size_t srcY;

    CUmemorytype srcMemoryType;
    const void *srcHost;
    CUdeviceptr srcDevice;
    CUarray srcArray;
    size_t srcPitch
    ;
    size_t dstXInBytes;
    size_t dstY;
    CUmemorytype dstMemoryType;
    void *dstHost;
    CUdeviceptr dstDevice;
    CUarray dstArray;
    size_t dstPitch;

    size_t WidthInBytes;
    size_t Height;
}

struct CUDA_MEMCPY3D
{
    size_t srcXInBytes;
    size_t srcY;
    size_t srcZ;
    size_t srcLOD;
    CUmemorytype srcMemoryType;
    const void *srcHost;
    CUdeviceptr srcDevice;
    CUarray srcArray;
    void *reserved0;
    size_t srcPitch;
    size_t srcHeight;
    size_t dstXInBytes;
    size_t dstY;
    size_t dstZ;
    size_t dstLOD;
    CUmemorytype dstMemoryType;
    void *dstHost;
    CUdeviceptr dstDevice;
    CUarray dstArray;
    void *reserved1;
    size_t dstPitch;
    size_t dstHeight;
    size_t WidthInBytes;
    size_t Height;
    size_t Depth;
}

struct CUDA_MEMCPY3D_PEER
{
    size_t srcXInBytes;
    size_t srcY;
    size_t srcZ;
    size_t srcLOD;
    CUmemorytype srcMemoryType;
    const void *srcHost;
    CUdeviceptr srcDevice;
    CUarray srcArray;
    CUcontext srcContext;
    size_t srcPitch;
    size_t srcHeight;
    size_t dstXInBytes;
    size_t dstY;
    size_t dstZ;
    size_t dstLOD;
    CUmemorytype dstMemoryType;
    void *dstHost;
    CUdeviceptr dstDevice;
    CUarray dstArray;
    CUcontext dstContext;
    size_t dstPitch;
    size_t dstHeight;
    size_t WidthInBytes;
    size_t Height;
    size_t Depth;
}

struct CUDA_ARRAY_DESCRIPTOR
{
    size_t Width;
    size_t Height;
    CUarray_format Format;
    uint NumChannels;
}

struct CUDA_ARRAY3D_DESCRIPTOR
{
    size_t Width;
    size_t Height;
    size_t Depth;

    CUarray_format Format;
    uint NumChannels;
    uint Flags;
}

struct CUDA_RESOURCE_DESC
{
    CUresourcetype resType;

    union res_st {
        struct array_st
        {
            CUarray hArray;
        }
        array_st array;

        struct mipmap_st
        {
            CUmipmappedArray hMipmappedArray;
        }
        mipmap_st mipmap;

        struct linear_st
        {
            CUdeviceptr devPtr;
            CUarray_format format;
            uint numChannels;
            size_t sizeInBytes;
        }
        linear_st linear;

        struct pitch2D_st
        {
            CUdeviceptr devPtr;
            CUarray_format format;
            uint numChannels;
            size_t width;
            size_t height;
            size_t pitchInBytes;
        }
        pitch2D_st pitch2D;

        struct reserved_st
        {
            int[32] reserved;
        }
        reserved_st reserved;
    }

    res_st res;
    uint flags;
}

struct CUDA_TEXTURE_DESC
{
    CUaddress_mode[3] addressMode;
    CUfilter_mode filterMode;
    uint flags;
    uint maxAnisotropy;
    CUfilter_mode mipmapFilterMode;
    float mipmapLevelBias;
    float minMipmapLevelClamp;
    float maxMipmapLevelClamp;
    int[16] reserved;
}

alias CUresourceViewFormat = int;
enum : CUresourceViewFormat
{
    CU_RES_VIEW_FORMAT_NONE          = 0x00,
    CU_RES_VIEW_FORMAT_UINT_1X8      = 0x01,
    CU_RES_VIEW_FORMAT_UINT_2X8      = 0x02,
    CU_RES_VIEW_FORMAT_UINT_4X8      = 0x03,
    CU_RES_VIEW_FORMAT_SINT_1X8      = 0x04,
    CU_RES_VIEW_FORMAT_SINT_2X8      = 0x05,
    CU_RES_VIEW_FORMAT_SINT_4X8      = 0x06,
    CU_RES_VIEW_FORMAT_UINT_1X16     = 0x07,
    CU_RES_VIEW_FORMAT_UINT_2X16     = 0x08,
    CU_RES_VIEW_FORMAT_UINT_4X16     = 0x09,
    CU_RES_VIEW_FORMAT_SINT_1X16     = 0x0a,
    CU_RES_VIEW_FORMAT_SINT_2X16     = 0x0b,
    CU_RES_VIEW_FORMAT_SINT_4X16     = 0x0c,
    CU_RES_VIEW_FORMAT_UINT_1X32     = 0x0d,
    CU_RES_VIEW_FORMAT_UINT_2X32     = 0x0e,
    CU_RES_VIEW_FORMAT_UINT_4X32     = 0x0f,
    CU_RES_VIEW_FORMAT_SINT_1X32     = 0x10,
    CU_RES_VIEW_FORMAT_SINT_2X32     = 0x11,
    CU_RES_VIEW_FORMAT_SINT_4X32     = 0x12,
    CU_RES_VIEW_FORMAT_FLOAT_1X16    = 0x13,
    CU_RES_VIEW_FORMAT_FLOAT_2X16    = 0x14,
    CU_RES_VIEW_FORMAT_FLOAT_4X16    = 0x15,
    CU_RES_VIEW_FORMAT_FLOAT_1X32    = 0x16,
    CU_RES_VIEW_FORMAT_FLOAT_2X32    = 0x17,
    CU_RES_VIEW_FORMAT_FLOAT_4X32    = 0x18,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC1  = 0x19,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC2  = 0x1a,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC3  = 0x1b,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC4  = 0x1c,
    CU_RES_VIEW_FORMAT_SIGNED_BC4    = 0x1d,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC5  = 0x1e,
    CU_RES_VIEW_FORMAT_SIGNED_BC5    = 0x1f,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC6H = 0x20,
    CU_RES_VIEW_FORMAT_SIGNED_BC6H   = 0x21,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC7  = 0x22
}

struct CUDA_RESOURCE_VIEW_DESC {
  CUresourceViewFormat format;
  size_t width;
  size_t height;
  size_t depth;
  uint firstMipmapLevel;
  uint lastMipmapLevel;
  uint firstLayer;
  uint lastLayer;
  uint[16] reserved;
}


struct CUDA_POINTER_ATTRIBUTE_P2P_TOKENS {
  ulong p2pToken;
  uint vaSpaceToken;
}

//
// New since CUDA >= 9.0
//

/**
 * Kernel launch parameters
 */
struct CUDA_LAUNCH_PARAMS {
  CUfunction _function;
  uint gridDimX;       /**< Width of grid in blocks */
  uint gridDimY;       /**< Height of grid in blocks */
  uint gridDimZ;       /**< Depth of grid in blocks */
  uint blockDimX;      /**< X dimension of each thread block */
  uint blockDimY;      /**< Y dimension of each thread block */
  uint blockDimZ;      /**< Z dimension of each thread block */
  uint sharedMemBytes; /**< Dynamic shared-memory size per thread block in bytes */
  CUstream hStream;            /**< Stream identifier */
  void **kernelParams;         /**< Array of pointers to kernel parameters */
}

//
// New since CUDA >= 10.0
//


/**
 * External memory handle types
 */
alias CUexternalMemoryHandleType = int;
enum : CUexternalMemoryHandleType {
    /**
     * Handle is an opaque file descriptor
     */
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD        = 1,
    /**
     * Handle is an opaque shared NT handle
     */
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32     = 2,
    /**
     * Handle is an opaque, globally shared handle
     */
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3,
    /**
     * Handle is a D3D12 heap object
     */
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP       = 4,
    /**
     * Handle is a D3D12 committed resource
     */
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE   = 5
}

/**
 * Indicates that the external memory object is a dedicated resource
 */
enum CUDA_EXTERNAL_MEMORY_DEDICATED   =  0x1;

/**
 * External memory handle descriptor
 */
struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC {
  /**
   * Type of the handle
   */
  CUexternalMemoryHandleType type;
  union handle_st {
    /**
     * File descriptor referencing the memory object. Valid
     * when type is
     * ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD
     */
    int fd;
    /**
     * Win32 handle referencing the semaphore object. Valid when
     * type is one of the following:
     * - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32
     * - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT
     * - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP
     * - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE
     * Exactly one of 'handle' and 'name' must be non-NULL. If
     * type is
     * ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT
     * then 'name' must be NULL.
     */
    struct win32_st {
      /**
       * Valid NT handle. Must be NULL if 'name' is non-NULL
       */
      void *handle;
      /**
       * Name of a valid memory object.
       * Must be NULL if 'handle' is non-NULL.
       */
      const void *name;
    }
    win32_st win32;
  }
  handle_st handle;
  /**
   * Size of the memory allocation
   */
  ulong size;
  /**
   * Flags must either be zero or ::CUDA_EXTERNAL_MEMORY_DEDICATED
   */
  uint flags;
  uint[16] reserved;
}

/**
 * External memory buffer descriptor
 */
struct CUDA_EXTERNAL_MEMORY_BUFFER_DESC {
  /**
   * Offset into the memory object where the buffer's base is
   */
  ulong offset;
  /**
   * Size of the buffer
   */
  ulong size;
  /**
   * Flags reserved for future use. Must be zero.
   */
  uint flags;
  uint[16] reserved;
}

/**
 * External memory mipmap descriptor
 */
struct CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC {
  /**
   * Offset into the memory object where the base level of the
   * mipmap chain is.
   */
  ulong offset;
  /**
   * Format, dimension and type of base level of the mipmap chain
   */
  CUDA_ARRAY3D_DESCRIPTOR arrayDesc;
  /**
   * Total number of levels in the mipmap chain
   */
  uint numLevels;
  uint[16] reserved;
}

/**
 * External semaphore handle types
 */
alias CUexternalSemaphoreHandleType = int;
enum : CUexternalSemaphoreHandleType {
  /**
   * Handle is an opaque file descriptor
   */
  CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD        = 1,
  /**
   * Handle is an opaque shared NT handle
   */
  CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32     = 2,
  /**
   * Handle is an opaque, globally shared handle
   */
  CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3,
  /**
   * Handle is a shared NT handle referencing a D3D12 fence object
   */
  CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE     = 4
}

/**
 * External semaphore handle descriptor
 */
struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC {
  /**
   * Type of the handle
   */
  CUexternalSemaphoreHandleType type;
  union handle_st {
    /**
     * File descriptor referencing the semaphore object. Valid
     * when type is
     * ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD
     */
    int fd;
    /**
     * Win32 handle referencing the semaphore object. Valid when
     * type is one of the following:
     * - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32
     * - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT
     * - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE
     * Exactly one of 'handle' and 'name' must be non-NULL. If
     * type is
     * ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT
     * then 'name' must be NULL.
     */
    struct win32_st {
      /**
       * Valid NT handle. Must be NULL if 'name' is non-NULL
       */
      void *handle;
      /**
       * Name of a valid synchronization primitive.
       * Must be NULL if 'handle' is non-NULL.
       */
      const void *name;
    }
    win32_st win32;
  }
  handle_st handle;
  /**
   * Flags reserved for the future. Must be zero.
   */
  uint flags;
  uint[16] reserved;
}

/**
 * External semaphore signal parameters
 */
struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS {
  struct params_st {
    /**
     * Parameters for fence objects
     */
    struct fence_st {
      /**
       * Value of fence to be signaled
       */
      ulong value;
    }
    fence_st fence;
    uint[16] reserved;
  }
  params_st params;
  /**
   * Flags reserved for the future. Must be zero.
   */
  uint flags;
  uint[16] reserved;
}

/**
 * External semaphore wait parameters
 */
struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS {
  struct params_st {
    /**
     * Parameters for fence objects
     */
    struct fence_st {
      /**
       * Value of fence to be waited on
       */
      ulong value;
    }
    fence_st fence;
    uint[16] reserved;
  }
  params_st params;
  /**
   * Flags reserved for the future. Must be zero.
   */
  uint flags;
  uint[16] reserved;
}

enum CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC  =  0x01;
enum CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC =  0x02;
enum CUDA_ARRAY3D_LAYERED       =  0x01;
enum CUDA_ARRAY3D_2DARRAY       =  0x01;
enum CUDA_ARRAY3D_SURFACE_LDST  =  0x02;
enum CUDA_ARRAY3D_CUBEMAP       =  0x04;
enum CUDA_ARRAY3D_TEXTURE_GATHER = 0x08;
enum CUDA_ARRAY3D_DEPTH_TEXTURE = 0x10;
enum CUDA_ARRAY3D_COLOR_ATTACHMENT = 0x20;
enum CU_TRSA_OVERRIDE_FORMAT = 0x01;
enum CU_TRSF_READ_AS_INTEGER        =  0x01;
enum CU_TRSF_NORMALIZED_COORDINATES =  0x02;
enum CU_TRSF_SRGB  = 0x10;
enum CU_LAUNCH_PARAM_END            = (cast(void*)0x00);
enum CU_LAUNCH_PARAM_BUFFER_POINTER = (cast(void*)0x01);
enum CU_LAUNCH_PARAM_BUFFER_SIZE    = (cast(void*)0x02);
enum CU_PARAM_TR_DEFAULT = -1;

enum CU_DEVICE_CPU              =  (cast(CUdevice)-1);

/**
 * Device that represents an invalid device
 */
enum CU_DEVICE_INVALID          =  (cast(CUdevice)-2);


extern(System) @nogc nothrow
{

  alias da_cuGetErrorString = CUresult function(CUresult error, const char **pStr);
  alias da_cuGetErrorName = CUresult function(CUresult error, const char **pStr);
  alias da_cuInit = CUresult function(uint Flags);
  alias da_cuDriverGetVersion = CUresult function(int *driverVersion);
  alias da_cuDeviceGet = CUresult function(CUdevice *device, int ordinal);
  alias da_cuDeviceGetCount = CUresult function(int *count);
  alias da_cuDeviceGetName = CUresult function(char *name, int len, CUdevice dev);
  alias da_cuDeviceGetUuid = CUresult function(CUuuid *uuid, CUdevice dev);
  //alias da_cuDeviceGetLuid = CUresult function(char *luid, uint *deviceNodeMask, CUdevice dev);
  alias da_cuDeviceTotalMem = CUresult function(size_t *bytes, CUdevice dev);
  alias da_cuDeviceGetAttribute = CUresult function(int *pi, CUdevice_attribute attrib, CUdevice dev);
  alias da_cuDeviceGetProperties = CUresult function(CUdevprop *prop, CUdevice dev);
  alias da_cuDeviceComputeCapability = CUresult function(int *major, int *minor, CUdevice dev);
  alias da_cuDevicePrimaryCtxRetain = CUresult function(CUcontext *pctx, CUdevice dev);
  alias da_cuDevicePrimaryCtxRelease = CUresult function(CUdevice dev);
  alias da_cuDevicePrimaryCtxSetFlags = CUresult function(CUdevice dev, uint flags);
  alias da_cuDevicePrimaryCtxGetState = CUresult function(CUdevice dev, uint *flags, int *active);
  alias da_cuDevicePrimaryCtxReset = CUresult function(CUdevice dev);
  alias da_cuCtxCreate = CUresult function(CUcontext *pctx, uint flags, CUdevice dev);
  alias da_cuCtxDestroy = CUresult function(CUcontext ctx);
  alias da_cuCtxPushCurrent = CUresult function(CUcontext ctx);
  alias da_cuCtxPopCurrent = CUresult function(CUcontext *pctx);
  alias da_cuCtxSetCurrent = CUresult function(CUcontext ctx);
  alias da_cuCtxGetCurrent = CUresult function(CUcontext *pctx);
  alias da_cuCtxGetDevice = CUresult function(CUdevice *device);
  alias da_cuCtxGetFlags = CUresult function(uint *flags);
  alias da_cuCtxSynchronize = CUresult function();
  alias da_cuCtxSetLimit = CUresult function(CUlimit limit, size_t value);
  alias da_cuCtxGetLimit = CUresult function(size_t *pvalue, CUlimit limit);
  alias da_cuCtxGetCacheConfig = CUresult function(CUfunc_cache *pconfig);
  alias da_cuCtxSetCacheConfig = CUresult function(CUfunc_cache config);
  alias da_cuCtxGetSharedMemConfig = CUresult function(CUsharedconfig *pConfig);
  alias da_cuCtxSetSharedMemConfig = CUresult function(CUsharedconfig config);
  alias da_cuCtxGetApiVersion = CUresult function(CUcontext ctx, uint *pVersion);
  alias da_cuCtxGetStreamPriorityRange = CUresult function(int *leastPriority, int *greatestPriority);
  alias da_cuCtxAttach = CUresult function(CUcontext *pctx, uint flags);
  alias da_cuCtxDetach = CUresult function(CUcontext ctx);
  alias da_cuModuleLoad = CUresult function(CUmodule *pModule, const char *fname);
  alias da_cuModuleLoadData = CUresult function(CUmodule *pModule, const void *image);
  alias da_cuModuleLoadDataEx = CUresult function(CUmodule *pModule, const void *image, uint numOptions, CUjit_option *options, void **optionValues);
  alias da_cuModuleLoadFatBinary = CUresult function(CUmodule *pModule, const void *fatCubin);
  alias da_cuModuleUnload = CUresult function(CUmodule hmod);
  alias da_cuModuleGetFunction = CUresult function(CUfunction *hfunc, CUmodule hmod, const char *name);
  alias da_cuModuleGetGlobal = CUresult function(CUdeviceptr *dptr, size_t *bytes, CUmodule hmod, const char *name);
  alias da_cuModuleGetTexRef = CUresult function(CUtexref *pTexRef, CUmodule hmod, const char *name);
  alias da_cuModuleGetSurfRef = CUresult function(CUsurfref *pSurfRef, CUmodule hmod, const char *name);
  alias da_cuLinkCreate = CUresult function(uint numOptions, CUjit_option *options, void **optionValues, CUlinkState *stateOut);
  alias da_cuLinkAddData = CUresult function(CUlinkState state, CUjitInputType type, void *data, size_t size, const char *name, uint numOptions, CUjit_option *options, void **optionValues);
  alias da_cuLinkAddFile = CUresult function(CUlinkState state, CUjitInputType type, const char *path, uint numOptions, CUjit_option *options, void **optionValues);
  alias da_cuLinkComplete = CUresult function(CUlinkState state, void **cubinOut, size_t *sizeOut);
  alias da_cuLinkDestroy = CUresult function(CUlinkState state);
  alias da_cuMemGetInfo = CUresult function(size_t *free, size_t *total);
  alias da_cuMemAlloc = CUresult function(CUdeviceptr *dptr, size_t bytesize);
  alias da_cuMemAllocPitch = CUresult function(CUdeviceptr *dptr, size_t *pPitch, size_t WidthInBytes, size_t Height, uint ElementSizeBytes);
  alias da_cuMemFree = CUresult function(CUdeviceptr dptr);
  alias da_cuMemGetAddressRange = CUresult function(CUdeviceptr *pbase, size_t *psize, CUdeviceptr dptr);
  alias da_cuMemAllocHost = CUresult function(void **pp, size_t bytesize);
  alias da_cuMemFreeHost = CUresult function(void *p);
  alias da_cuMemHostAlloc = CUresult function(void **pp, size_t bytesize, uint Flags);
  alias da_cuMemHostGetDevicePointer = CUresult function(CUdeviceptr *pdptr, void *p, uint Flags);
  alias da_cuMemHostGetFlags = CUresult function(uint *pFlags, void *p);
  alias da_cuMemAllocManaged = CUresult function(CUdeviceptr *dptr, size_t bytesize, uint flags);
  alias da_cuDeviceGetByPCIBusId = CUresult function(CUdevice *dev, const char *pciBusId);
  alias da_cuDeviceGetPCIBusId = CUresult function(char *pciBusId, int len, CUdevice dev);
  alias da_cuIpcGetEventHandle = CUresult function(CUipcEventHandle *pHandle, CUevent event);
  alias da_cuIpcOpenEventHandle = CUresult function(CUevent *phEvent, CUipcEventHandle handle);
  alias da_cuIpcGetMemHandle = CUresult function(CUipcMemHandle *pHandle, CUdeviceptr dptr);
  alias da_cuIpcOpenMemHandle = CUresult function(CUdeviceptr *pdptr, CUipcMemHandle handle, uint Flags);
  alias da_cuIpcCloseMemHandle = CUresult function(CUdeviceptr dptr);
  alias da_cuMemHostRegister = CUresult function(void *p, size_t bytesize, uint Flags);
  alias da_cuMemHostUnregister = CUresult function(void *p);
  alias da_cuMemcpy = CUresult function(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount);
  alias da_cuMemcpyPeer = CUresult function(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount);
  alias da_cuMemcpyHtoD = CUresult function(CUdeviceptr dstDevice, const void *srcHost, size_t ByteCount);
  alias da_cuMemcpyDtoH = CUresult function(void *dstHost, CUdeviceptr srcDevice, size_t ByteCount);
  alias da_cuMemcpyDtoD = CUresult function(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount);
  alias da_cuMemcpyDtoA = CUresult function(CUarray dstArray, size_t dstOffset, CUdeviceptr srcDevice, size_t ByteCount);
  alias da_cuMemcpyAtoD = CUresult function(CUdeviceptr dstDevice, CUarray srcArray, size_t srcOffset, size_t ByteCount);
  alias da_cuMemcpyHtoA = CUresult function(CUarray dstArray, size_t dstOffset, const void *srcHost, size_t ByteCount);
  alias da_cuMemcpyAtoH = CUresult function(void *dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount);
  alias da_cuMemcpyAtoA = CUresult function(CUarray dstArray, size_t dstOffset, CUarray srcArray, size_t srcOffset, size_t ByteCount);
  alias da_cuMemcpy2D = CUresult function(const CUDA_MEMCPY2D *pCopy);
  alias da_cuMemcpy2DUnaligned = CUresult function(const CUDA_MEMCPY2D *pCopy);
  alias da_cuMemcpy3D = CUresult function(const CUDA_MEMCPY3D *pCopy);
  alias da_cuMemcpy3DPeer = CUresult function(const CUDA_MEMCPY3D_PEER *pCopy);
  alias da_cuMemcpyAsync = CUresult function(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount, CUstream hStream);
  alias da_cuMemcpyPeerAsync = CUresult function(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount, CUstream hStream);
  alias da_cuMemcpyHtoDAsync = CUresult function(CUdeviceptr dstDevice, const void *srcHost, size_t ByteCount, CUstream hStream);
  alias da_cuMemcpyDtoHAsync = CUresult function(void *dstHost, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream);
  alias da_cuMemcpyDtoDAsync = CUresult function(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream);
  alias da_cuMemcpyHtoAAsync = CUresult function(CUarray dstArray, size_t dstOffset, const void *srcHost, size_t ByteCount, CUstream hStream);
  alias da_cuMemcpyAtoHAsync = CUresult function(void *dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount, CUstream hStream);
  alias da_cuMemcpy2DAsync = CUresult function(const CUDA_MEMCPY2D *pCopy, CUstream hStream);
  alias da_cuMemcpy3DAsync = CUresult function(const CUDA_MEMCPY3D *pCopy, CUstream hStream);
  alias da_cuMemcpy3DPeerAsync = CUresult function(const CUDA_MEMCPY3D_PEER *pCopy, CUstream hStream);
  alias da_cuMemsetD8 = CUresult function(CUdeviceptr dstDevice, dchar uc, size_t N);
  alias da_cuMemsetD16 = CUresult function(CUdeviceptr dstDevice, ushort us, size_t N);
  alias da_cuMemsetD32 = CUresult function(CUdeviceptr dstDevice, uint ui, size_t N);
  alias da_cuMemsetD2D8 = CUresult function(CUdeviceptr dstDevice, size_t dstPitch, dchar uc, size_t Width, size_t Height);
  alias da_cuMemsetD2D16 = CUresult function(CUdeviceptr dstDevice, size_t dstPitch, ushort us, size_t Width, size_t Height);
  alias da_cuMemsetD2D32 = CUresult function(CUdeviceptr dstDevice, size_t dstPitch, uint ui, size_t Width, size_t Height);
  alias da_cuMemsetD8Async = CUresult function(CUdeviceptr dstDevice, dchar uc, size_t N, CUstream hStream);
  alias da_cuMemsetD16Async = CUresult function(CUdeviceptr dstDevice, ushort us, size_t N, CUstream hStream);
  alias da_cuMemsetD32Async = CUresult function(CUdeviceptr dstDevice, uint ui, size_t N, CUstream hStream);
  alias da_cuMemsetD2D8Async = CUresult function(CUdeviceptr dstDevice, size_t dstPitch, dchar uc, size_t Width, size_t Height, CUstream hStream);
  alias da_cuMemsetD2D16Async = CUresult function(CUdeviceptr dstDevice, size_t dstPitch, ushort us, size_t Width, size_t Height, CUstream hStream);
  alias da_cuMemsetD2D32Async = CUresult function(CUdeviceptr dstDevice, size_t dstPitch, uint ui, size_t Width, size_t Height, CUstream hStream);
  alias da_cuArrayCreate = CUresult function(CUarray *pHandle, const CUDA_ARRAY_DESCRIPTOR *pAllocateArray);
  alias da_cuArrayGetDescriptor = CUresult function(CUDA_ARRAY_DESCRIPTOR *pArrayDescriptor, CUarray hArray);
  alias da_cuArrayDestroy = CUresult function(CUarray hArray);
  alias da_cuArray3DCreate = CUresult function(CUarray *pHandle, const CUDA_ARRAY3D_DESCRIPTOR *pAllocateArray);
  alias da_cuArray3DGetDescriptor = CUresult function(CUDA_ARRAY3D_DESCRIPTOR *pArrayDescriptor, CUarray hArray);
  alias da_cuMipmappedArrayCreate = CUresult function(CUmipmappedArray *pHandle, const CUDA_ARRAY3D_DESCRIPTOR *pMipmappedArrayDesc, uint numMipmapLevels);
  alias da_cuMipmappedArrayGetLevel = CUresult function(CUarray *pLevelArray, CUmipmappedArray hMipmappedArray, uint level);
  alias da_cuMipmappedArrayDestroy = CUresult function(CUmipmappedArray hMipmappedArray);
  alias da_cuPointerGetAttribute = CUresult function(void *data, CUpointer_attribute attribute, CUdeviceptr ptr);
  alias da_cuMemPrefetchAsync = CUresult function(CUdeviceptr devPtr, size_t count, CUdevice dstDevice, CUstream hStream);
  alias da_cuMemAdvise = CUresult function(CUdeviceptr devPtr, size_t count, CUmem_advise advice, CUdevice device);
  alias da_cuMemRangeGetAttribute = CUresult function(void *data, size_t dataSize, CUmem_range_attribute attribute, CUdeviceptr devPtr, size_t count);
  alias da_cuMemRangeGetAttributes = CUresult function(void **data, size_t *dataSizes, CUmem_range_attribute *attributes, size_t numAttributes, CUdeviceptr devPtr, size_t count);
  alias da_cuPointerSetAttribute = CUresult function(const void *value, CUpointer_attribute attribute, CUdeviceptr ptr);
  alias da_cuPointerGetAttributes = CUresult function(uint numAttributes, CUpointer_attribute *attributes, void **data, CUdeviceptr ptr);
  alias da_cuStreamCreate = CUresult function(CUstream *phStream, uint Flags);
  alias da_cuStreamCreateWithPriority = CUresult function(CUstream *phStream, uint flags, int priority);
  alias da_cuStreamGetPriority = CUresult function(CUstream hStream, int *priority);
  alias da_cuStreamGetFlags = CUresult function(CUstream hStream, uint *flags);
  alias da_cuStreamGetCtx = CUresult function(CUstream hStream, CUcontext *pctx);
  alias da_cuStreamWaitEvent = CUresult function(CUstream hStream, CUevent hEvent, uint Flags);
  alias da_cuStreamAddCallback = CUresult function(CUstream hStream, CUstreamCallback callback, void *userData, uint flags);
  alias da_cuStreamBeginCapture = CUresult function(CUstream hStream);
  alias da_cuStreamEndCapture = CUresult function(CUstream hStream, CUgraph *phGraph);
  alias da_cuStreamIsCapturing = CUresult function(CUstream hStream, CUstreamCaptureStatus *captureStatus);
  alias da_cuStreamAttachMemAsync = CUresult function(CUstream hStream, CUdeviceptr dptr, size_t length, uint flags);
  alias da_cuStreamQuery = CUresult function(CUstream hStream);
  alias da_cuStreamSynchronize = CUresult function(CUstream hStream);
  alias da_cuStreamDestroy = CUresult function(CUstream hStream);
  alias da_cuEventCreate = CUresult function(CUevent *phEvent, uint Flags);
  alias da_cuEventRecord = CUresult function(CUevent hEvent, CUstream hStream);
  alias da_cuEventQuery = CUresult function(CUevent hEvent);
  alias da_cuEventSynchronize = CUresult function(CUevent hEvent);
  alias da_cuEventDestroy = CUresult function(CUevent hEvent);
  alias da_cuEventElapsedTime = CUresult function(float *pMilliseconds, CUevent hStart, CUevent hEnd);
  alias da_cuImportExternalMemory = CUresult function(CUexternalMemory *extMem_out, const CUDA_EXTERNAL_MEMORY_HANDLE_DESC *memHandleDesc);
  alias da_cuExternalMemoryGetMappedBuffer = CUresult function(CUdeviceptr *devPtr, CUexternalMemory extMem, const CUDA_EXTERNAL_MEMORY_BUFFER_DESC *bufferDesc);
  alias da_cuExternalMemoryGetMappedMipmappedArray = CUresult function(CUmipmappedArray *mipmap, CUexternalMemory extMem, const CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC *mipmapDesc);
  alias da_cuDestroyExternalMemory = CUresult function(CUexternalMemory extMem);
  alias da_cuImportExternalSemaphore = CUresult function(CUexternalSemaphore *extSem_out, const CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC *semHandleDesc);
  alias da_cuSignalExternalSemaphoresAsync = CUresult function(const CUexternalSemaphore *extSemArray, const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS *paramsArray, uint numExtSems, CUstream stream);
  alias da_cuWaitExternalSemaphoresAsync = CUresult function(const CUexternalSemaphore *extSemArray, const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS *paramsArray, uint numExtSems, CUstream stream);
  alias da_cuDestroyExternalSemaphore = CUresult function(CUexternalSemaphore extSem);
  alias da_cuStreamWaitValue32 = CUresult function(CUstream stream, CUdeviceptr addr, cuuint32_t value, uint flags);
  alias da_cuStreamWaitValue64 = CUresult function(CUstream stream, CUdeviceptr addr, cuuint64_t value, uint flags);
  alias da_cuStreamWriteValue32 = CUresult function(CUstream stream, CUdeviceptr addr, cuuint32_t value, uint flags);
  alias da_cuStreamWriteValue64 = CUresult function(CUstream stream, CUdeviceptr addr, cuuint64_t value, uint flags);
  alias da_cuStreamBatchMemOp = CUresult function(CUstream stream, uint count, CUstreamBatchMemOpParams *paramArray, uint flags);
  alias da_cuFuncGetAttribute = CUresult function(int *pi, CUfunction_attribute attrib, CUfunction hfunc);
  alias da_cuFuncSetAttribute = CUresult function(CUfunction hfunc, CUfunction_attribute attrib, int value);
  alias da_cuFuncSetCacheConfig = CUresult function(CUfunction hfunc, CUfunc_cache config);
  alias da_cuFuncSetSharedMemConfig = CUresult function(CUfunction hfunc, CUsharedconfig config);
  alias da_cuLaunchKernel = CUresult function(CUfunction f,uint gridDimX,uint gridDimY,uint gridDimZ,uint blockDimX,uint blockDimY,uint blockDimZ,uint sharedMemBytes,CUstream hStream,void **kernelParams,void **extra);
  alias da_cuLaunchCooperativeKernel = CUresult function(CUfunction f,uint gridDimX,uint gridDimY,uint gridDimZ,uint blockDimX,uint blockDimY,uint blockDimZ,uint sharedMemBytes,CUstream hStream,void **kernelParams);
  alias da_cuLaunchCooperativeKernelMultiDevice = CUresult function(CUDA_LAUNCH_PARAMS *launchParamsList, uint numDevices, uint flags);
  alias da_cuLaunchHostFunc = CUresult function(CUstream hStream, CUhostFn fn, void *userData);
  alias da_cuFuncSetBlockShape = CUresult function(CUfunction hfunc, int x, int y, int z);
  alias da_cuFuncSetSharedSize = CUresult function(CUfunction hfunc, uint bytes);
  alias da_cuParamSetSize = CUresult function(CUfunction hfunc, uint numbytes);
  alias da_cuParamSeti = CUresult function(CUfunction hfunc, int offset, uint value);
  alias da_cuParamSetf = CUresult function(CUfunction hfunc, int offset, float value);
  alias da_cuParamSetv = CUresult function(CUfunction hfunc, int offset, void *ptr, uint numbytes);
  alias da_cuLaunch = CUresult function(CUfunction f);
  alias da_cuLaunchGrid = CUresult function(CUfunction f, int grid_width, int grid_height);
  alias da_cuLaunchGridAsync = CUresult function(CUfunction f, int grid_width, int grid_height, CUstream hStream);
  alias da_cuParamSetTexRef = CUresult function(CUfunction hfunc, int texunit, CUtexref hTexRef);
  alias da_cuGraphCreate = CUresult function(CUgraph *phGraph, uint flags);
  alias da_cuGraphAddKernelNode = CUresult function(CUgraphNode *phGraphNode, CUgraph hGraph, CUgraphNode *dependencies, size_t numDependencies, const CUDA_KERNEL_NODE_PARAMS *nodeParams);
  alias da_cuGraphKernelNodeGetParams = CUresult function(CUgraphNode hNode, CUDA_KERNEL_NODE_PARAMS *nodeParams);
  alias da_cuGraphKernelNodeSetParams = CUresult function(CUgraphNode hNode, const CUDA_KERNEL_NODE_PARAMS *nodeParams);
  alias da_cuGraphAddMemcpyNode = CUresult function(CUgraphNode *phGraphNode, CUgraph hGraph, CUgraphNode *dependencies, size_t numDependencies, const CUDA_MEMCPY3D *copyParams, CUcontext ctx);
  alias da_cuGraphMemcpyNodeGetParams = CUresult function(CUgraphNode hNode, CUDA_MEMCPY3D *nodeParams);
  alias da_cuGraphMemcpyNodeSetParams = CUresult function(CUgraphNode hNode, const CUDA_MEMCPY3D *nodeParams);
  alias da_cuGraphAddMemsetNode = CUresult function(CUgraphNode *phGraphNode, CUgraph hGraph, CUgraphNode *dependencies, size_t numDependencies, const CUDA_MEMSET_NODE_PARAMS *memsetParams, CUcontext ctx);
  alias da_cuGraphMemsetNodeGetParams = CUresult function(CUgraphNode hNode, CUDA_MEMSET_NODE_PARAMS *nodeParams);
  alias da_cuGraphMemsetNodeSetParams = CUresult function(CUgraphNode hNode, const CUDA_MEMSET_NODE_PARAMS *nodeParams);
  alias da_cuGraphAddHostNode = CUresult function(CUgraphNode *phGraphNode, CUgraph hGraph, CUgraphNode *dependencies, size_t numDependencies, const CUDA_HOST_NODE_PARAMS *nodeParams);
  alias da_cuGraphHostNodeGetParams = CUresult function(CUgraphNode hNode, CUDA_HOST_NODE_PARAMS *nodeParams);
  alias da_cuGraphHostNodeSetParams = CUresult function(CUgraphNode hNode, const CUDA_HOST_NODE_PARAMS *nodeParams);
  alias da_cuGraphAddChildGraphNode = CUresult function(CUgraphNode *phGraphNode, CUgraph hGraph, CUgraphNode *dependencies, size_t numDependencies, CUgraph childGraph);
  alias da_cuGraphChildGraphNodeGetGraph = CUresult function(CUgraphNode hNode, CUgraph *phGraph);
  alias da_cuGraphAddEmptyNode = CUresult function(CUgraphNode *phGraphNode, CUgraph hGraph, CUgraphNode *dependencies, size_t numDependencies);
  alias da_cuGraphClone = CUresult function(CUgraph *phGraphClone, CUgraph originalGraph);
  alias da_cuGraphNodeFindInClone = CUresult function(CUgraphNode *phNode, CUgraphNode hOriginalNode, CUgraph hClonedGraph);
  alias da_cuGraphNodeGetType = CUresult function(CUgraphNode hNode, CUgraphNodeType *type);
  alias da_cuGraphGetNodes = CUresult function(CUgraph hGraph, CUgraphNode *nodes, size_t *numNodes);
  alias da_cuGraphGetRootNodes = CUresult function(CUgraph hGraph, CUgraphNode *rootNodes, size_t *numRootNodes);
  alias da_cuGraphGetEdges = CUresult function(CUgraph hGraph, CUgraphNode *from, CUgraphNode *to, size_t *numEdges);
  alias da_cuGraphNodeGetDependencies = CUresult function(CUgraphNode hNode, CUgraphNode *dependencies, size_t *numDependencies);
  alias da_cuGraphNodeGetDependentNodes = CUresult function(CUgraphNode hNode, CUgraphNode *dependentNodes, size_t *numDependentNodes);
  alias da_cuGraphAddDependencies = CUresult function(CUgraph hGraph, CUgraphNode *from, CUgraphNode *to, size_t numDependencies);
  alias da_cuGraphRemoveDependencies = CUresult function(CUgraph hGraph, CUgraphNode *from, CUgraphNode *to, size_t numDependencies);
  alias da_cuGraphDestroyNode = CUresult function(CUgraphNode hNode);
  alias da_cuGraphInstantiate = CUresult function(CUgraphExec *phGraphExec, CUgraph hGraph, CUgraphNode *phErrorNode, char *logBuffer, size_t bufferSize);
  alias da_cuGraphLaunch = CUresult function(CUgraphExec hGraphExec, CUstream hStream);
  alias da_cuGraphExecDestroy = CUresult function(CUgraphExec hGraphExec);
  alias da_cuGraphDestroy = CUresult function(CUgraph hGraph);
  alias da_cuOccupancyMaxActiveBlocksPerMultiprocessor = CUresult function(int *numBlocks, CUfunction func, int blockSize, size_t dynamicSMemSize);
  alias da_cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags = CUresult function(int *numBlocks, CUfunction func, int blockSize, size_t dynamicSMemSize, uint flags);
  alias da_cuOccupancyMaxPotentialBlockSize = CUresult function(int *minGridSize, int *blockSize, CUfunction func, CUoccupancyB2DSize blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit);
  alias da_cuOccupancyMaxPotentialBlockSizeWithFlags = CUresult function(int *minGridSize, int *blockSize, CUfunction func, CUoccupancyB2DSize blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit, uint flags);
  alias da_cuTexRefSetArray = CUresult function(CUtexref hTexRef, CUarray hArray, uint Flags);
  alias da_cuTexRefSetMipmappedArray = CUresult function(CUtexref hTexRef, CUmipmappedArray hMipmappedArray, uint Flags);
  alias da_cuTexRefSetAddress = CUresult function(size_t *ByteOffset, CUtexref hTexRef, CUdeviceptr dptr, size_t bytes);
  alias da_cuTexRefSetAddress2D = CUresult function(CUtexref hTexRef, const CUDA_ARRAY_DESCRIPTOR *desc, CUdeviceptr dptr, size_t Pitch);
  alias da_cuTexRefSetFormat = CUresult function(CUtexref hTexRef, CUarray_format fmt, int NumPackedComponents);
  alias da_cuTexRefSetAddressMode = CUresult function(CUtexref hTexRef, int dim, CUaddress_mode am);
  alias da_cuTexRefSetFilterMode = CUresult function(CUtexref hTexRef, CUfilter_mode fm);
  alias da_cuTexRefSetMipmapFilterMode = CUresult function(CUtexref hTexRef, CUfilter_mode fm);
  alias da_cuTexRefSetMipmapLevelBias = CUresult function(CUtexref hTexRef, float bias);
  alias da_cuTexRefSetMipmapLevelClamp = CUresult function(CUtexref hTexRef, float minMipmapLevelClamp, float maxMipmapLevelClamp);
  alias da_cuTexRefSetMaxAnisotropy = CUresult function(CUtexref hTexRef, uint maxAniso);
  alias da_cuTexRefSetBorderColor = CUresult function(CUtexref hTexRef, float *pBorderColor);
  alias da_cuTexRefSetFlags = CUresult function(CUtexref hTexRef, uint Flags);
  alias da_cuTexRefGetAddress = CUresult function(CUdeviceptr *pdptr, CUtexref hTexRef);
  alias da_cuTexRefGetArray = CUresult function(CUarray *phArray, CUtexref hTexRef);
  alias da_cuTexRefGetMipmappedArray = CUresult function(CUmipmappedArray *phMipmappedArray, CUtexref hTexRef);
  alias da_cuTexRefGetAddressMode = CUresult function(CUaddress_mode *pam, CUtexref hTexRef, int dim);
  alias da_cuTexRefGetFilterMode = CUresult function(CUfilter_mode *pfm, CUtexref hTexRef);
  alias da_cuTexRefGetFormat = CUresult function(CUarray_format *pFormat, int *pNumChannels, CUtexref hTexRef);
  alias da_cuTexRefGetMipmapFilterMode = CUresult function(CUfilter_mode *pfm, CUtexref hTexRef);
  alias da_cuTexRefGetMipmapLevelBias = CUresult function(float *pbias, CUtexref hTexRef);
  alias da_cuTexRefGetMipmapLevelClamp = CUresult function(float *pminMipmapLevelClamp, float *pmaxMipmapLevelClamp, CUtexref hTexRef);
  alias da_cuTexRefGetMaxAnisotropy = CUresult function(int *pmaxAniso, CUtexref hTexRef);
  alias da_cuTexRefGetBorderColor = CUresult function(float *pBorderColor, CUtexref hTexRef);
  alias da_cuTexRefGetFlags = CUresult function(uint *pFlags, CUtexref hTexRef);
  alias da_cuTexRefCreate = CUresult function(CUtexref *pTexRef);
  alias da_cuTexRefDestroy = CUresult function(CUtexref hTexRef);
  alias da_cuSurfRefSetArray = CUresult function(CUsurfref hSurfRef, CUarray hArray, uint Flags);
  alias da_cuSurfRefGetArray = CUresult function(CUarray *phArray, CUsurfref hSurfRef);
  alias da_cuTexObjectCreate = CUresult function(CUtexObject *pTexObject, const CUDA_RESOURCE_DESC *pResDesc, const CUDA_TEXTURE_DESC *pTexDesc, const CUDA_RESOURCE_VIEW_DESC *pResViewDesc);
  alias da_cuTexObjectDestroy = CUresult function(CUtexObject texObject);
  alias da_cuTexObjectGetResourceDesc = CUresult function(CUDA_RESOURCE_DESC *pResDesc, CUtexObject texObject);
  alias da_cuTexObjectGetTextureDesc = CUresult function(CUDA_TEXTURE_DESC *pTexDesc, CUtexObject texObject);
  alias da_cuTexObjectGetResourceViewDesc = CUresult function(CUDA_RESOURCE_VIEW_DESC *pResViewDesc, CUtexObject texObject);
  alias da_cuSurfObjectCreate = CUresult function(CUsurfObject *pSurfObject, const CUDA_RESOURCE_DESC *pResDesc);
  alias da_cuSurfObjectDestroy = CUresult function(CUsurfObject surfObject);
  alias da_cuSurfObjectGetResourceDesc = CUresult function(CUDA_RESOURCE_DESC *pResDesc, CUsurfObject surfObject);
  alias da_cuDeviceCanAccessPeer = CUresult function(int *canAccessPeer, CUdevice dev, CUdevice peerDev);
  alias da_cuCtxEnablePeerAccess = CUresult function(CUcontext peerContext, uint Flags);
  alias da_cuCtxDisablePeerAccess = CUresult function(CUcontext peerContext);
  alias da_cuDeviceGetP2PAttribute = CUresult function(int* value, CUdevice_P2PAttribute attrib, CUdevice srcDevice, CUdevice dstDevice);
  alias da_cuGraphicsUnregisterResource = CUresult function(CUgraphicsResource resource);
  alias da_cuGraphicsSubResourceGetMappedArray = CUresult function(CUarray *pArray, CUgraphicsResource resource, uint arrayIndex, uint mipLevel);
  alias da_cuGraphicsResourceGetMappedMipmappedArray = CUresult function(CUmipmappedArray *pMipmappedArray, CUgraphicsResource resource);
  alias da_cuGraphicsResourceGetMappedPointer = CUresult function(CUdeviceptr *pDevPtr, size_t *pSize, CUgraphicsResource resource);
  alias da_cuGraphicsResourceSetMapFlags = CUresult function(CUgraphicsResource resource, uint flags);
  alias da_cuGraphicsMapResources = CUresult function(uint count, CUgraphicsResource *resources, CUstream hStream);
  alias da_cuGraphicsUnmapResources = CUresult function(uint count, CUgraphicsResource *resources, CUstream hStream);
  alias da_cuGetExportTable = CUresult function(const void **ppExportTable, const CUuuid *pExportTableId);
  alias da_cuTexRefSetAddress2D_v2 = CUresult function(CUtexref hTexRef, const CUDA_ARRAY_DESCRIPTOR *desc, CUdeviceptr dptr, size_t Pitch);



}

__gshared
{
  da_cuGetErrorString cuGetErrorString;
  da_cuGetErrorName cuGetErrorName;
  da_cuInit cuInit;
  da_cuDriverGetVersion cuDriverGetVersion;
  da_cuDeviceGet cuDeviceGet;
  da_cuDeviceGetCount cuDeviceGetCount;
  da_cuDeviceGetName cuDeviceGetName;
  da_cuDeviceGetUuid cuDeviceGetUuid;
  //da_cuDeviceGetLuid cuDeviceGetLuid;
  da_cuDeviceTotalMem cuDeviceTotalMem;
  da_cuDeviceGetAttribute cuDeviceGetAttribute;
  da_cuDeviceGetProperties cuDeviceGetProperties;
  da_cuDeviceComputeCapability cuDeviceComputeCapability;
  da_cuDevicePrimaryCtxRetain cuDevicePrimaryCtxRetain;
  da_cuDevicePrimaryCtxRelease cuDevicePrimaryCtxRelease;
  da_cuDevicePrimaryCtxSetFlags cuDevicePrimaryCtxSetFlags;
  da_cuDevicePrimaryCtxGetState cuDevicePrimaryCtxGetState;
  da_cuDevicePrimaryCtxReset cuDevicePrimaryCtxReset;
  da_cuCtxCreate cuCtxCreate;
  da_cuCtxDestroy cuCtxDestroy;
  da_cuCtxPushCurrent cuCtxPushCurrent;
  da_cuCtxPopCurrent cuCtxPopCurrent;
  da_cuCtxSetCurrent cuCtxSetCurrent;
  da_cuCtxGetCurrent cuCtxGetCurrent;
  da_cuCtxGetDevice cuCtxGetDevice;
  da_cuCtxGetFlags cuCtxGetFlags;
  da_cuCtxSynchronize cuCtxSynchronize;
  da_cuCtxSetLimit cuCtxSetLimit;
  da_cuCtxGetLimit cuCtxGetLimit;
  da_cuCtxGetCacheConfig cuCtxGetCacheConfig;
  da_cuCtxSetCacheConfig cuCtxSetCacheConfig;
  da_cuCtxGetSharedMemConfig cuCtxGetSharedMemConfig;
  da_cuCtxSetSharedMemConfig cuCtxSetSharedMemConfig;
  da_cuCtxGetApiVersion cuCtxGetApiVersion;
  da_cuCtxGetStreamPriorityRange cuCtxGetStreamPriorityRange;
  da_cuCtxAttach cuCtxAttach;
  da_cuCtxDetach cuCtxDetach;
  da_cuModuleLoad cuModuleLoad;
  da_cuModuleLoadData cuModuleLoadData;
  da_cuModuleLoadDataEx cuModuleLoadDataEx;
  da_cuModuleLoadFatBinary cuModuleLoadFatBinary;
  da_cuModuleUnload cuModuleUnload;
  da_cuModuleGetFunction cuModuleGetFunction;
  da_cuModuleGetGlobal cuModuleGetGlobal;
  da_cuModuleGetTexRef cuModuleGetTexRef;
  da_cuModuleGetSurfRef cuModuleGetSurfRef;
  da_cuLinkCreate cuLinkCreate;
  da_cuLinkAddData cuLinkAddData;
  da_cuLinkAddFile cuLinkAddFile;
  da_cuLinkComplete cuLinkComplete;
  da_cuLinkDestroy cuLinkDestroy;
  da_cuMemGetInfo cuMemGetInfo;
  da_cuMemAlloc cuMemAlloc;
  da_cuMemAllocPitch cuMemAllocPitch;
  da_cuMemFree cuMemFree;
  da_cuMemGetAddressRange cuMemGetAddressRange;
  da_cuMemAllocHost cuMemAllocHost;
  da_cuMemFreeHost cuMemFreeHost;
  da_cuMemHostAlloc cuMemHostAlloc;
  da_cuMemHostGetDevicePointer cuMemHostGetDevicePointer;
  da_cuMemHostGetFlags cuMemHostGetFlags;
  da_cuMemAllocManaged cuMemAllocManaged;
  da_cuDeviceGetByPCIBusId cuDeviceGetByPCIBusId;
  da_cuDeviceGetPCIBusId cuDeviceGetPCIBusId;
  da_cuIpcGetEventHandle cuIpcGetEventHandle;
  da_cuIpcOpenEventHandle cuIpcOpenEventHandle;
  da_cuIpcGetMemHandle cuIpcGetMemHandle;
  da_cuIpcOpenMemHandle cuIpcOpenMemHandle;
  da_cuIpcCloseMemHandle cuIpcCloseMemHandle;
  da_cuMemHostRegister cuMemHostRegister;
  da_cuMemHostUnregister cuMemHostUnregister;
  da_cuMemcpy cuMemcpy;
  da_cuMemcpyPeer cuMemcpyPeer;
  da_cuMemcpyHtoD cuMemcpyHtoD;
  da_cuMemcpyDtoH cuMemcpyDtoH;
  da_cuMemcpyDtoD cuMemcpyDtoD;
  da_cuMemcpyDtoA cuMemcpyDtoA;
  da_cuMemcpyAtoD cuMemcpyAtoD;
  da_cuMemcpyHtoA cuMemcpyHtoA;
  da_cuMemcpyAtoH cuMemcpyAtoH;
  da_cuMemcpyAtoA cuMemcpyAtoA;
  da_cuMemcpy2D cuMemcpy2D;
  da_cuMemcpy2DUnaligned cuMemcpy2DUnaligned;
  da_cuMemcpy3D cuMemcpy3D;
  da_cuMemcpy3DPeer cuMemcpy3DPeer;
  da_cuMemcpyAsync cuMemcpyAsync;
  da_cuMemcpyPeerAsync cuMemcpyPeerAsync;
  da_cuMemcpyHtoDAsync cuMemcpyHtoDAsync;
  da_cuMemcpyDtoHAsync cuMemcpyDtoHAsync;
  da_cuMemcpyDtoDAsync cuMemcpyDtoDAsync;
  da_cuMemcpyHtoAAsync cuMemcpyHtoAAsync;
  da_cuMemcpyAtoHAsync cuMemcpyAtoHAsync;
  da_cuMemcpy2DAsync cuMemcpy2DAsync;
  da_cuMemcpy3DAsync cuMemcpy3DAsync;
  da_cuMemcpy3DPeerAsync cuMemcpy3DPeerAsync;
  da_cuMemsetD8 cuMemsetD8;
  da_cuMemsetD16 cuMemsetD16;
  da_cuMemsetD32 cuMemsetD32;
  da_cuMemsetD2D8 cuMemsetD2D8;
  da_cuMemsetD2D16 cuMemsetD2D16;
  da_cuMemsetD2D32 cuMemsetD2D32;
  da_cuMemsetD8Async cuMemsetD8Async;
  da_cuMemsetD16Async cuMemsetD16Async;
  da_cuMemsetD32Async cuMemsetD32Async;
  da_cuMemsetD2D8Async cuMemsetD2D8Async;
  da_cuMemsetD2D16Async cuMemsetD2D16Async;
  da_cuMemsetD2D32Async cuMemsetD2D32Async;
  da_cuArrayCreate cuArrayCreate;
  da_cuArrayGetDescriptor cuArrayGetDescriptor;
  da_cuArrayDestroy cuArrayDestroy;
  da_cuArray3DCreate cuArray3DCreate;
  da_cuArray3DGetDescriptor cuArray3DGetDescriptor;
  da_cuMipmappedArrayCreate cuMipmappedArrayCreate;
  da_cuMipmappedArrayGetLevel cuMipmappedArrayGetLevel;
  da_cuMipmappedArrayDestroy cuMipmappedArrayDestroy;
  da_cuPointerGetAttribute cuPointerGetAttribute;
  da_cuMemPrefetchAsync cuMemPrefetchAsync;
  da_cuMemAdvise cuMemAdvise;
  da_cuMemRangeGetAttribute cuMemRangeGetAttribute;
  da_cuMemRangeGetAttributes cuMemRangeGetAttributes;
  da_cuPointerSetAttribute cuPointerSetAttribute;
  da_cuPointerGetAttributes cuPointerGetAttributes;
  da_cuStreamCreate cuStreamCreate;
  da_cuStreamCreateWithPriority cuStreamCreateWithPriority;
  da_cuStreamGetPriority cuStreamGetPriority;
  da_cuStreamGetFlags cuStreamGetFlags;
  da_cuStreamGetCtx cuStreamGetCtx;
  da_cuStreamWaitEvent cuStreamWaitEvent;
  da_cuStreamAddCallback cuStreamAddCallback;
  da_cuStreamBeginCapture cuStreamBeginCapture;
  da_cuStreamEndCapture cuStreamEndCapture;
  da_cuStreamIsCapturing cuStreamIsCapturing;
  da_cuStreamAttachMemAsync cuStreamAttachMemAsync;
  da_cuStreamQuery cuStreamQuery;
  da_cuStreamSynchronize cuStreamSynchronize;
  da_cuStreamDestroy cuStreamDestroy;
  da_cuEventCreate cuEventCreate;
  da_cuEventRecord cuEventRecord;
  da_cuEventQuery cuEventQuery;
  da_cuEventSynchronize cuEventSynchronize;
  da_cuEventDestroy cuEventDestroy;
  da_cuEventElapsedTime cuEventElapsedTime;
  da_cuImportExternalMemory cuImportExternalMemory;
  da_cuExternalMemoryGetMappedBuffer cuExternalMemoryGetMappedBuffer;
  da_cuExternalMemoryGetMappedMipmappedArray cuExternalMemoryGetMappedMipmappedArray;
  da_cuDestroyExternalMemory cuDestroyExternalMemory;
  da_cuImportExternalSemaphore cuImportExternalSemaphore;
  da_cuSignalExternalSemaphoresAsync cuSignalExternalSemaphoresAsync;
  da_cuWaitExternalSemaphoresAsync cuWaitExternalSemaphoresAsync;
  da_cuDestroyExternalSemaphore cuDestroyExternalSemaphore;
  da_cuStreamWaitValue32 cuStreamWaitValue32;
  da_cuStreamWaitValue64 cuStreamWaitValue64;
  da_cuStreamWriteValue32 cuStreamWriteValue32;
  da_cuStreamWriteValue64 cuStreamWriteValue64;
  da_cuStreamBatchMemOp cuStreamBatchMemOp;
  da_cuFuncGetAttribute cuFuncGetAttribute;
  da_cuFuncSetAttribute cuFuncSetAttribute;
  da_cuFuncSetCacheConfig cuFuncSetCacheConfig;
  da_cuFuncSetSharedMemConfig cuFuncSetSharedMemConfig;
  da_cuLaunchKernel cuLaunchKernel;
  da_cuLaunchCooperativeKernel cuLaunchCooperativeKernel;
  da_cuLaunchCooperativeKernelMultiDevice cuLaunchCooperativeKernelMultiDevice;
  da_cuLaunchHostFunc cuLaunchHostFunc;
  da_cuFuncSetBlockShape cuFuncSetBlockShape;
  da_cuFuncSetSharedSize cuFuncSetSharedSize;
  da_cuParamSetSize cuParamSetSize;
  da_cuParamSeti cuParamSeti;
  da_cuParamSetf cuParamSetf;
  da_cuParamSetv cuParamSetv;
  da_cuLaunch cuLaunch;
  da_cuLaunchGrid cuLaunchGrid;
  da_cuLaunchGridAsync cuLaunchGridAsync;
  da_cuParamSetTexRef cuParamSetTexRef;
  da_cuGraphCreate cuGraphCreate;
  da_cuGraphAddKernelNode cuGraphAddKernelNode;
  da_cuGraphKernelNodeGetParams cuGraphKernelNodeGetParams;
  da_cuGraphKernelNodeSetParams cuGraphKernelNodeSetParams;
  da_cuGraphAddMemcpyNode cuGraphAddMemcpyNode;
  da_cuGraphMemcpyNodeGetParams cuGraphMemcpyNodeGetParams;
  da_cuGraphMemcpyNodeSetParams cuGraphMemcpyNodeSetParams;
  da_cuGraphAddMemsetNode cuGraphAddMemsetNode;
  da_cuGraphMemsetNodeGetParams cuGraphMemsetNodeGetParams;
  da_cuGraphMemsetNodeSetParams cuGraphMemsetNodeSetParams;
  da_cuGraphAddHostNode cuGraphAddHostNode;
  da_cuGraphHostNodeGetParams cuGraphHostNodeGetParams;
  da_cuGraphHostNodeSetParams cuGraphHostNodeSetParams;
  da_cuGraphAddChildGraphNode cuGraphAddChildGraphNode;
  da_cuGraphChildGraphNodeGetGraph cuGraphChildGraphNodeGetGraph;
  da_cuGraphAddEmptyNode cuGraphAddEmptyNode;
  da_cuGraphClone cuGraphClone;
  da_cuGraphNodeFindInClone cuGraphNodeFindInClone;
  da_cuGraphNodeGetType cuGraphNodeGetType;
  da_cuGraphGetNodes cuGraphGetNodes;
  da_cuGraphGetRootNodes cuGraphGetRootNodes;
  da_cuGraphGetEdges cuGraphGetEdges;
  da_cuGraphNodeGetDependencies cuGraphNodeGetDependencies;
  da_cuGraphNodeGetDependentNodes cuGraphNodeGetDependentNodes;
  da_cuGraphAddDependencies cuGraphAddDependencies;
  da_cuGraphRemoveDependencies cuGraphRemoveDependencies;
  da_cuGraphDestroyNode cuGraphDestroyNode;
  da_cuGraphInstantiate cuGraphInstantiate;
  da_cuGraphLaunch cuGraphLaunch;
  da_cuGraphExecDestroy cuGraphExecDestroy;
  da_cuGraphDestroy cuGraphDestroy;
  da_cuOccupancyMaxActiveBlocksPerMultiprocessor cuOccupancyMaxActiveBlocksPerMultiprocessor;
  da_cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags;
  da_cuOccupancyMaxPotentialBlockSize cuOccupancyMaxPotentialBlockSize;
  da_cuOccupancyMaxPotentialBlockSizeWithFlags cuOccupancyMaxPotentialBlockSizeWithFlags;
  da_cuTexRefSetArray cuTexRefSetArray;
  da_cuTexRefSetMipmappedArray cuTexRefSetMipmappedArray;
  da_cuTexRefSetAddress cuTexRefSetAddress;
  da_cuTexRefSetAddress2D cuTexRefSetAddress2D;
  da_cuTexRefSetFormat cuTexRefSetFormat;
  da_cuTexRefSetAddressMode cuTexRefSetAddressMode;
  da_cuTexRefSetFilterMode cuTexRefSetFilterMode;
  da_cuTexRefSetMipmapFilterMode cuTexRefSetMipmapFilterMode;
  da_cuTexRefSetMipmapLevelBias cuTexRefSetMipmapLevelBias;
  da_cuTexRefSetMipmapLevelClamp cuTexRefSetMipmapLevelClamp;
  da_cuTexRefSetMaxAnisotropy cuTexRefSetMaxAnisotropy;
  da_cuTexRefSetBorderColor cuTexRefSetBorderColor;
  da_cuTexRefSetFlags cuTexRefSetFlags;
  da_cuTexRefGetAddress cuTexRefGetAddress;
  da_cuTexRefGetArray cuTexRefGetArray;
  da_cuTexRefGetMipmappedArray cuTexRefGetMipmappedArray;
  da_cuTexRefGetAddressMode cuTexRefGetAddressMode;
  da_cuTexRefGetFilterMode cuTexRefGetFilterMode;
  da_cuTexRefGetFormat cuTexRefGetFormat;
  da_cuTexRefGetMipmapFilterMode cuTexRefGetMipmapFilterMode;
  da_cuTexRefGetMipmapLevelBias cuTexRefGetMipmapLevelBias;
  da_cuTexRefGetMipmapLevelClamp cuTexRefGetMipmapLevelClamp;
  da_cuTexRefGetMaxAnisotropy cuTexRefGetMaxAnisotropy;
  da_cuTexRefGetBorderColor cuTexRefGetBorderColor;
  da_cuTexRefGetFlags cuTexRefGetFlags;
  da_cuTexRefCreate cuTexRefCreate;
  da_cuTexRefDestroy cuTexRefDestroy;
  da_cuSurfRefSetArray cuSurfRefSetArray;
  da_cuSurfRefGetArray cuSurfRefGetArray;
  da_cuTexObjectCreate cuTexObjectCreate;
  da_cuTexObjectDestroy cuTexObjectDestroy;
  da_cuTexObjectGetResourceDesc cuTexObjectGetResourceDesc;
  da_cuTexObjectGetTextureDesc cuTexObjectGetTextureDesc;
  da_cuTexObjectGetResourceViewDesc cuTexObjectGetResourceViewDesc;
  da_cuSurfObjectCreate cuSurfObjectCreate;
  da_cuSurfObjectDestroy cuSurfObjectDestroy;
  da_cuSurfObjectGetResourceDesc cuSurfObjectGetResourceDesc;
  da_cuDeviceCanAccessPeer cuDeviceCanAccessPeer;
  da_cuCtxEnablePeerAccess cuCtxEnablePeerAccess;
  da_cuCtxDisablePeerAccess cuCtxDisablePeerAccess;
  da_cuDeviceGetP2PAttribute cuDeviceGetP2PAttribute;
  da_cuGraphicsUnregisterResource cuGraphicsUnregisterResource;
  da_cuGraphicsSubResourceGetMappedArray cuGraphicsSubResourceGetMappedArray;
  da_cuGraphicsResourceGetMappedMipmappedArray cuGraphicsResourceGetMappedMipmappedArray;
  da_cuGraphicsResourceGetMappedPointer cuGraphicsResourceGetMappedPointer;
  da_cuGraphicsResourceSetMapFlags cuGraphicsResourceSetMapFlags;
  da_cuGraphicsMapResources cuGraphicsMapResources;
  da_cuGraphicsUnmapResources cuGraphicsUnmapResources;
  da_cuGetExportTable cuGetExportTable;
  da_cuTexRefSetAddress2D_v2 cuTexRefSetAddress2D_v2;

}


// Driver API loader
class DerelictCUDADriverLoader : SharedLibLoader
{
  protected
  {
    override void loadSymbols()
    {
      // Note: new versions of API are to be loaded (_v2 or _v3 suffices)
      // DerelictCUDA only represents the newest API and load the latest version of functions
      // Previous versions of APIs, if necessary, can be done with previous versions of DerelictCUDA.
      bindFunc(cast(void**)&cuGetErrorString, "cuGetErrorString");
      bindFunc(cast(void**)&cuGetErrorName, "cuGetErrorName");
      bindFunc(cast(void**)&cuInit, "cuInit");
      bindFunc(cast(void**)&cuDriverGetVersion, "cuDriverGetVersion");
      bindFunc(cast(void**)&cuDeviceGet, "cuDeviceGet");
      bindFunc(cast(void**)&cuDeviceGetCount, "cuDeviceGetCount");
      bindFunc(cast(void**)&cuDeviceGetName, "cuDeviceGetName");
      bindFunc(cast(void**)&cuDeviceGetUuid, "cuDeviceGetUuid");
      //bindFunc(cast(void**)&cuDeviceGetLuid, "cuDeviceGetLuid");
      bindFunc(cast(void**)&cuDeviceTotalMem, "cuDeviceTotalMem");
      bindFunc(cast(void**)&cuDeviceGetAttribute, "cuDeviceGetAttribute");
      bindFunc(cast(void**)&cuDeviceGetProperties, "cuDeviceGetProperties");
      bindFunc(cast(void**)&cuDeviceComputeCapability, "cuDeviceComputeCapability");
      bindFunc(cast(void**)&cuDevicePrimaryCtxRetain, "cuDevicePrimaryCtxRetain");
      bindFunc(cast(void**)&cuDevicePrimaryCtxRelease, "cuDevicePrimaryCtxRelease");
      bindFunc(cast(void**)&cuDevicePrimaryCtxSetFlags, "cuDevicePrimaryCtxSetFlags");
      bindFunc(cast(void**)&cuDevicePrimaryCtxGetState, "cuDevicePrimaryCtxGetState");
      bindFunc(cast(void**)&cuDevicePrimaryCtxReset, "cuDevicePrimaryCtxReset");
      bindFunc(cast(void**)&cuCtxCreate, "cuCtxCreate");
      bindFunc(cast(void**)&cuCtxDestroy, "cuCtxDestroy");
      bindFunc(cast(void**)&cuCtxPushCurrent, "cuCtxPushCurrent");
      bindFunc(cast(void**)&cuCtxPopCurrent, "cuCtxPopCurrent");
      bindFunc(cast(void**)&cuCtxSetCurrent, "cuCtxSetCurrent");
      bindFunc(cast(void**)&cuCtxGetCurrent, "cuCtxGetCurrent");
      bindFunc(cast(void**)&cuCtxGetDevice, "cuCtxGetDevice");
      bindFunc(cast(void**)&cuCtxGetFlags, "cuCtxGetFlags");
      bindFunc(cast(void**)&cuCtxSynchronize, "cuCtxSynchronize");
      bindFunc(cast(void**)&cuCtxSetLimit, "cuCtxSetLimit");
      bindFunc(cast(void**)&cuCtxGetLimit, "cuCtxGetLimit");
      bindFunc(cast(void**)&cuCtxGetCacheConfig, "cuCtxGetCacheConfig");
      bindFunc(cast(void**)&cuCtxSetCacheConfig, "cuCtxSetCacheConfig");
      bindFunc(cast(void**)&cuCtxGetSharedMemConfig, "cuCtxGetSharedMemConfig");
      bindFunc(cast(void**)&cuCtxSetSharedMemConfig, "cuCtxSetSharedMemConfig");
      bindFunc(cast(void**)&cuCtxGetApiVersion, "cuCtxGetApiVersion");
      bindFunc(cast(void**)&cuCtxGetStreamPriorityRange, "cuCtxGetStreamPriorityRange");
      bindFunc(cast(void**)&cuCtxAttach, "cuCtxAttach");
      bindFunc(cast(void**)&cuCtxDetach, "cuCtxDetach");
      bindFunc(cast(void**)&cuModuleLoad, "cuModuleLoad");
      bindFunc(cast(void**)&cuModuleLoadData, "cuModuleLoadData");
      bindFunc(cast(void**)&cuModuleLoadDataEx, "cuModuleLoadDataEx");
      bindFunc(cast(void**)&cuModuleLoadFatBinary, "cuModuleLoadFatBinary");
      bindFunc(cast(void**)&cuModuleUnload, "cuModuleUnload");
      bindFunc(cast(void**)&cuModuleGetFunction, "cuModuleGetFunction");
      bindFunc(cast(void**)&cuModuleGetGlobal, "cuModuleGetGlobal");
      bindFunc(cast(void**)&cuModuleGetTexRef, "cuModuleGetTexRef");
      bindFunc(cast(void**)&cuModuleGetSurfRef, "cuModuleGetSurfRef");
      bindFunc(cast(void**)&cuLinkCreate, "cuLinkCreate");
      bindFunc(cast(void**)&cuLinkAddData, "cuLinkAddData");
      bindFunc(cast(void**)&cuLinkAddFile, "cuLinkAddFile");
      bindFunc(cast(void**)&cuLinkComplete, "cuLinkComplete");
      bindFunc(cast(void**)&cuLinkDestroy, "cuLinkDestroy");
      bindFunc(cast(void**)&cuMemGetInfo, "cuMemGetInfo");
      bindFunc(cast(void**)&cuMemAlloc, "cuMemAlloc");
      bindFunc(cast(void**)&cuMemAllocPitch, "cuMemAllocPitch");
      bindFunc(cast(void**)&cuMemFree, "cuMemFree");
      bindFunc(cast(void**)&cuMemGetAddressRange, "cuMemGetAddressRange");
      bindFunc(cast(void**)&cuMemAllocHost, "cuMemAllocHost");
      bindFunc(cast(void**)&cuMemFreeHost, "cuMemFreeHost");
      bindFunc(cast(void**)&cuMemHostAlloc, "cuMemHostAlloc");
      bindFunc(cast(void**)&cuMemHostGetDevicePointer, "cuMemHostGetDevicePointer");
      bindFunc(cast(void**)&cuMemHostGetFlags, "cuMemHostGetFlags");
      bindFunc(cast(void**)&cuMemAllocManaged, "cuMemAllocManaged");
      bindFunc(cast(void**)&cuDeviceGetByPCIBusId, "cuDeviceGetByPCIBusId");
      bindFunc(cast(void**)&cuDeviceGetPCIBusId, "cuDeviceGetPCIBusId");
      bindFunc(cast(void**)&cuIpcGetEventHandle, "cuIpcGetEventHandle");
      bindFunc(cast(void**)&cuIpcOpenEventHandle, "cuIpcOpenEventHandle");
      bindFunc(cast(void**)&cuIpcGetMemHandle, "cuIpcGetMemHandle");
      bindFunc(cast(void**)&cuIpcOpenMemHandle, "cuIpcOpenMemHandle");
      bindFunc(cast(void**)&cuIpcCloseMemHandle, "cuIpcCloseMemHandle");
      bindFunc(cast(void**)&cuMemHostRegister, "cuMemHostRegister");
      bindFunc(cast(void**)&cuMemHostUnregister, "cuMemHostUnregister");
      bindFunc(cast(void**)&cuMemcpy, "cuMemcpy");
      bindFunc(cast(void**)&cuMemcpyPeer, "cuMemcpyPeer");
      bindFunc(cast(void**)&cuMemcpyHtoD, "cuMemcpyHtoD");
      bindFunc(cast(void**)&cuMemcpyDtoH, "cuMemcpyDtoH");
      bindFunc(cast(void**)&cuMemcpyDtoD, "cuMemcpyDtoD");
      bindFunc(cast(void**)&cuMemcpyDtoA, "cuMemcpyDtoA");
      bindFunc(cast(void**)&cuMemcpyAtoD, "cuMemcpyAtoD");
      bindFunc(cast(void**)&cuMemcpyHtoA, "cuMemcpyHtoA");
      bindFunc(cast(void**)&cuMemcpyAtoH, "cuMemcpyAtoH");
      bindFunc(cast(void**)&cuMemcpyAtoA, "cuMemcpyAtoA");
      bindFunc(cast(void**)&cuMemcpy2D, "cuMemcpy2D");
      bindFunc(cast(void**)&cuMemcpy2DUnaligned, "cuMemcpy2DUnaligned");
      bindFunc(cast(void**)&cuMemcpy3D, "cuMemcpy3D");
      bindFunc(cast(void**)&cuMemcpy3DPeer, "cuMemcpy3DPeer");
      bindFunc(cast(void**)&cuMemcpyAsync, "cuMemcpyAsync");
      bindFunc(cast(void**)&cuMemcpyPeerAsync, "cuMemcpyPeerAsync");
      bindFunc(cast(void**)&cuMemcpyHtoDAsync, "cuMemcpyHtoDAsync");
      bindFunc(cast(void**)&cuMemcpyDtoHAsync, "cuMemcpyDtoHAsync");
      bindFunc(cast(void**)&cuMemcpyDtoDAsync, "cuMemcpyDtoDAsync");
      bindFunc(cast(void**)&cuMemcpyHtoAAsync, "cuMemcpyHtoAAsync");
      bindFunc(cast(void**)&cuMemcpyAtoHAsync, "cuMemcpyAtoHAsync");
      bindFunc(cast(void**)&cuMemcpy2DAsync, "cuMemcpy2DAsync");
      bindFunc(cast(void**)&cuMemcpy3DAsync, "cuMemcpy3DAsync");
      bindFunc(cast(void**)&cuMemcpy3DPeerAsync, "cuMemcpy3DPeerAsync");
      bindFunc(cast(void**)&cuMemsetD8, "cuMemsetD8");
      bindFunc(cast(void**)&cuMemsetD16, "cuMemsetD16");
      bindFunc(cast(void**)&cuMemsetD32, "cuMemsetD32");
      bindFunc(cast(void**)&cuMemsetD2D8, "cuMemsetD2D8");
      bindFunc(cast(void**)&cuMemsetD2D16, "cuMemsetD2D16");
      bindFunc(cast(void**)&cuMemsetD2D32, "cuMemsetD2D32");
      bindFunc(cast(void**)&cuMemsetD8Async, "cuMemsetD8Async");
      bindFunc(cast(void**)&cuMemsetD16Async, "cuMemsetD16Async");
      bindFunc(cast(void**)&cuMemsetD32Async, "cuMemsetD32Async");
      bindFunc(cast(void**)&cuMemsetD2D8Async, "cuMemsetD2D8Async");
      bindFunc(cast(void**)&cuMemsetD2D16Async, "cuMemsetD2D16Async");
      bindFunc(cast(void**)&cuMemsetD2D32Async, "cuMemsetD2D32Async");
      bindFunc(cast(void**)&cuArrayCreate, "cuArrayCreate");
      bindFunc(cast(void**)&cuArrayGetDescriptor, "cuArrayGetDescriptor");
      bindFunc(cast(void**)&cuArrayDestroy, "cuArrayDestroy");
      bindFunc(cast(void**)&cuArray3DCreate, "cuArray3DCreate");
      bindFunc(cast(void**)&cuArray3DGetDescriptor, "cuArray3DGetDescriptor");
      bindFunc(cast(void**)&cuMipmappedArrayCreate, "cuMipmappedArrayCreate");
      bindFunc(cast(void**)&cuMipmappedArrayGetLevel, "cuMipmappedArrayGetLevel");
      bindFunc(cast(void**)&cuMipmappedArrayDestroy, "cuMipmappedArrayDestroy");
      bindFunc(cast(void**)&cuPointerGetAttribute, "cuPointerGetAttribute");
      bindFunc(cast(void**)&cuMemPrefetchAsync, "cuMemPrefetchAsync");
      bindFunc(cast(void**)&cuMemAdvise, "cuMemAdvise");
      bindFunc(cast(void**)&cuMemRangeGetAttribute, "cuMemRangeGetAttribute");
      bindFunc(cast(void**)&cuMemRangeGetAttributes, "cuMemRangeGetAttributes");
      bindFunc(cast(void**)&cuPointerSetAttribute, "cuPointerSetAttribute");
      bindFunc(cast(void**)&cuPointerGetAttributes, "cuPointerGetAttributes");
      bindFunc(cast(void**)&cuStreamCreate, "cuStreamCreate");
      bindFunc(cast(void**)&cuStreamCreateWithPriority, "cuStreamCreateWithPriority");
      bindFunc(cast(void**)&cuStreamGetPriority, "cuStreamGetPriority");
      bindFunc(cast(void**)&cuStreamGetFlags, "cuStreamGetFlags");
      bindFunc(cast(void**)&cuStreamGetCtx, "cuStreamGetCtx");
      bindFunc(cast(void**)&cuStreamWaitEvent, "cuStreamWaitEvent");
      bindFunc(cast(void**)&cuStreamAddCallback, "cuStreamAddCallback");
      bindFunc(cast(void**)&cuStreamBeginCapture, "cuStreamBeginCapture");
      bindFunc(cast(void**)&cuStreamEndCapture, "cuStreamEndCapture");
      bindFunc(cast(void**)&cuStreamIsCapturing, "cuStreamIsCapturing");
      bindFunc(cast(void**)&cuStreamAttachMemAsync, "cuStreamAttachMemAsync");
      bindFunc(cast(void**)&cuStreamQuery, "cuStreamQuery");
      bindFunc(cast(void**)&cuStreamSynchronize, "cuStreamSynchronize");
      bindFunc(cast(void**)&cuStreamDestroy, "cuStreamDestroy");
      bindFunc(cast(void**)&cuEventCreate, "cuEventCreate");
      bindFunc(cast(void**)&cuEventRecord, "cuEventRecord");
      bindFunc(cast(void**)&cuEventQuery, "cuEventQuery");
      bindFunc(cast(void**)&cuEventSynchronize, "cuEventSynchronize");
      bindFunc(cast(void**)&cuEventDestroy, "cuEventDestroy");
      bindFunc(cast(void**)&cuEventElapsedTime, "cuEventElapsedTime");
      bindFunc(cast(void**)&cuImportExternalMemory, "cuImportExternalMemory");
      bindFunc(cast(void**)&cuExternalMemoryGetMappedBuffer, "cuExternalMemoryGetMappedBuffer");
      bindFunc(cast(void**)&cuExternalMemoryGetMappedMipmappedArray, "cuExternalMemoryGetMappedMipmappedArray");
      bindFunc(cast(void**)&cuDestroyExternalMemory, "cuDestroyExternalMemory");
      bindFunc(cast(void**)&cuImportExternalSemaphore, "cuImportExternalSemaphore");
      bindFunc(cast(void**)&cuSignalExternalSemaphoresAsync, "cuSignalExternalSemaphoresAsync");
      bindFunc(cast(void**)&cuWaitExternalSemaphoresAsync, "cuWaitExternalSemaphoresAsync");
      bindFunc(cast(void**)&cuDestroyExternalSemaphore, "cuDestroyExternalSemaphore");
      bindFunc(cast(void**)&cuStreamWaitValue32, "cuStreamWaitValue32");
      bindFunc(cast(void**)&cuStreamWaitValue64, "cuStreamWaitValue64");
      bindFunc(cast(void**)&cuStreamWriteValue32, "cuStreamWriteValue32");
      bindFunc(cast(void**)&cuStreamWriteValue64, "cuStreamWriteValue64");
      bindFunc(cast(void**)&cuStreamBatchMemOp, "cuStreamBatchMemOp");
      bindFunc(cast(void**)&cuFuncGetAttribute, "cuFuncGetAttribute");
      bindFunc(cast(void**)&cuFuncSetAttribute, "cuFuncSetAttribute");
      bindFunc(cast(void**)&cuFuncSetCacheConfig, "cuFuncSetCacheConfig");
      bindFunc(cast(void**)&cuFuncSetSharedMemConfig, "cuFuncSetSharedMemConfig");
      bindFunc(cast(void**)&cuLaunchKernel, "cuLaunchKernel");
      bindFunc(cast(void**)&cuLaunchCooperativeKernel, "cuLaunchCooperativeKernel");
      bindFunc(cast(void**)&cuLaunchCooperativeKernelMultiDevice, "cuLaunchCooperativeKernelMultiDevice");
      bindFunc(cast(void**)&cuLaunchHostFunc, "cuLaunchHostFunc");
      bindFunc(cast(void**)&cuFuncSetBlockShape, "cuFuncSetBlockShape");
      bindFunc(cast(void**)&cuFuncSetSharedSize, "cuFuncSetSharedSize");
      bindFunc(cast(void**)&cuParamSetSize, "cuParamSetSize");
      bindFunc(cast(void**)&cuParamSeti, "cuParamSeti");
      bindFunc(cast(void**)&cuParamSetf, "cuParamSetf");
      bindFunc(cast(void**)&cuParamSetv, "cuParamSetv");
      bindFunc(cast(void**)&cuLaunch, "cuLaunch");
      bindFunc(cast(void**)&cuLaunchGrid, "cuLaunchGrid");
      bindFunc(cast(void**)&cuLaunchGridAsync, "cuLaunchGridAsync");
      bindFunc(cast(void**)&cuParamSetTexRef, "cuParamSetTexRef");
      bindFunc(cast(void**)&cuGraphCreate, "cuGraphCreate");
      bindFunc(cast(void**)&cuGraphAddKernelNode, "cuGraphAddKernelNode");
      bindFunc(cast(void**)&cuGraphKernelNodeGetParams, "cuGraphKernelNodeGetParams");
      bindFunc(cast(void**)&cuGraphKernelNodeSetParams, "cuGraphKernelNodeSetParams");
      bindFunc(cast(void**)&cuGraphAddMemcpyNode, "cuGraphAddMemcpyNode");
      bindFunc(cast(void**)&cuGraphMemcpyNodeGetParams, "cuGraphMemcpyNodeGetParams");
      bindFunc(cast(void**)&cuGraphMemcpyNodeSetParams, "cuGraphMemcpyNodeSetParams");
      bindFunc(cast(void**)&cuGraphAddMemsetNode, "cuGraphAddMemsetNode");
      bindFunc(cast(void**)&cuGraphMemsetNodeGetParams, "cuGraphMemsetNodeGetParams");
      bindFunc(cast(void**)&cuGraphMemsetNodeSetParams, "cuGraphMemsetNodeSetParams");
      bindFunc(cast(void**)&cuGraphAddHostNode, "cuGraphAddHostNode");
      bindFunc(cast(void**)&cuGraphHostNodeGetParams, "cuGraphHostNodeGetParams");
      bindFunc(cast(void**)&cuGraphHostNodeSetParams, "cuGraphHostNodeSetParams");
      bindFunc(cast(void**)&cuGraphAddChildGraphNode, "cuGraphAddChildGraphNode");
      bindFunc(cast(void**)&cuGraphChildGraphNodeGetGraph, "cuGraphChildGraphNodeGetGraph");
      bindFunc(cast(void**)&cuGraphAddEmptyNode, "cuGraphAddEmptyNode");
      bindFunc(cast(void**)&cuGraphClone, "cuGraphClone");
      bindFunc(cast(void**)&cuGraphNodeFindInClone, "cuGraphNodeFindInClone");
      bindFunc(cast(void**)&cuGraphNodeGetType, "cuGraphNodeGetType");
      bindFunc(cast(void**)&cuGraphGetNodes, "cuGraphGetNodes");
      bindFunc(cast(void**)&cuGraphGetRootNodes, "cuGraphGetRootNodes");
      bindFunc(cast(void**)&cuGraphGetEdges, "cuGraphGetEdges");
      bindFunc(cast(void**)&cuGraphNodeGetDependencies, "cuGraphNodeGetDependencies");
      bindFunc(cast(void**)&cuGraphNodeGetDependentNodes, "cuGraphNodeGetDependentNodes");
      bindFunc(cast(void**)&cuGraphAddDependencies, "cuGraphAddDependencies");
      bindFunc(cast(void**)&cuGraphRemoveDependencies, "cuGraphRemoveDependencies");
      bindFunc(cast(void**)&cuGraphDestroyNode, "cuGraphDestroyNode");
      bindFunc(cast(void**)&cuGraphInstantiate, "cuGraphInstantiate");
      bindFunc(cast(void**)&cuGraphLaunch, "cuGraphLaunch");
      bindFunc(cast(void**)&cuGraphExecDestroy, "cuGraphExecDestroy");
      bindFunc(cast(void**)&cuGraphDestroy, "cuGraphDestroy");
      bindFunc(cast(void**)&cuOccupancyMaxActiveBlocksPerMultiprocessor, "cuOccupancyMaxActiveBlocksPerMultiprocessor");
      bindFunc(cast(void**)&cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags, "cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags");
      bindFunc(cast(void**)&cuOccupancyMaxPotentialBlockSize, "cuOccupancyMaxPotentialBlockSize");
      bindFunc(cast(void**)&cuOccupancyMaxPotentialBlockSizeWithFlags, "cuOccupancyMaxPotentialBlockSizeWithFlags");
      bindFunc(cast(void**)&cuTexRefSetArray, "cuTexRefSetArray");
      bindFunc(cast(void**)&cuTexRefSetMipmappedArray, "cuTexRefSetMipmappedArray");
      bindFunc(cast(void**)&cuTexRefSetAddress, "cuTexRefSetAddress");
      bindFunc(cast(void**)&cuTexRefSetAddress2D, "cuTexRefSetAddress2D");
      bindFunc(cast(void**)&cuTexRefSetFormat, "cuTexRefSetFormat");
      bindFunc(cast(void**)&cuTexRefSetAddressMode, "cuTexRefSetAddressMode");
      bindFunc(cast(void**)&cuTexRefSetFilterMode, "cuTexRefSetFilterMode");
      bindFunc(cast(void**)&cuTexRefSetMipmapFilterMode, "cuTexRefSetMipmapFilterMode");
      bindFunc(cast(void**)&cuTexRefSetMipmapLevelBias, "cuTexRefSetMipmapLevelBias");
      bindFunc(cast(void**)&cuTexRefSetMipmapLevelClamp, "cuTexRefSetMipmapLevelClamp");
      bindFunc(cast(void**)&cuTexRefSetMaxAnisotropy, "cuTexRefSetMaxAnisotropy");
      bindFunc(cast(void**)&cuTexRefSetBorderColor, "cuTexRefSetBorderColor");
      bindFunc(cast(void**)&cuTexRefSetFlags, "cuTexRefSetFlags");
      bindFunc(cast(void**)&cuTexRefGetAddress, "cuTexRefGetAddress");
      bindFunc(cast(void**)&cuTexRefGetArray, "cuTexRefGetArray");
      bindFunc(cast(void**)&cuTexRefGetMipmappedArray, "cuTexRefGetMipmappedArray");
      bindFunc(cast(void**)&cuTexRefGetAddressMode, "cuTexRefGetAddressMode");
      bindFunc(cast(void**)&cuTexRefGetFilterMode, "cuTexRefGetFilterMode");
      bindFunc(cast(void**)&cuTexRefGetFormat, "cuTexRefGetFormat");
      bindFunc(cast(void**)&cuTexRefGetMipmapFilterMode, "cuTexRefGetMipmapFilterMode");
      bindFunc(cast(void**)&cuTexRefGetMipmapLevelBias, "cuTexRefGetMipmapLevelBias");
      bindFunc(cast(void**)&cuTexRefGetMipmapLevelClamp, "cuTexRefGetMipmapLevelClamp");
      bindFunc(cast(void**)&cuTexRefGetMaxAnisotropy, "cuTexRefGetMaxAnisotropy");
      bindFunc(cast(void**)&cuTexRefGetBorderColor, "cuTexRefGetBorderColor");
      bindFunc(cast(void**)&cuTexRefGetFlags, "cuTexRefGetFlags");
      bindFunc(cast(void**)&cuTexRefCreate, "cuTexRefCreate");
      bindFunc(cast(void**)&cuTexRefDestroy, "cuTexRefDestroy");
      bindFunc(cast(void**)&cuSurfRefSetArray, "cuSurfRefSetArray");
      bindFunc(cast(void**)&cuSurfRefGetArray, "cuSurfRefGetArray");
      bindFunc(cast(void**)&cuTexObjectCreate, "cuTexObjectCreate");
      bindFunc(cast(void**)&cuTexObjectDestroy, "cuTexObjectDestroy");
      bindFunc(cast(void**)&cuTexObjectGetResourceDesc, "cuTexObjectGetResourceDesc");
      bindFunc(cast(void**)&cuTexObjectGetTextureDesc, "cuTexObjectGetTextureDesc");
      bindFunc(cast(void**)&cuTexObjectGetResourceViewDesc, "cuTexObjectGetResourceViewDesc");
      bindFunc(cast(void**)&cuSurfObjectCreate, "cuSurfObjectCreate");
      bindFunc(cast(void**)&cuSurfObjectDestroy, "cuSurfObjectDestroy");
      bindFunc(cast(void**)&cuSurfObjectGetResourceDesc, "cuSurfObjectGetResourceDesc");
      bindFunc(cast(void**)&cuDeviceCanAccessPeer, "cuDeviceCanAccessPeer");
      bindFunc(cast(void**)&cuCtxEnablePeerAccess, "cuCtxEnablePeerAccess");
      bindFunc(cast(void**)&cuCtxDisablePeerAccess, "cuCtxDisablePeerAccess");
      bindFunc(cast(void**)&cuDeviceGetP2PAttribute, "cuDeviceGetP2PAttribute");
      bindFunc(cast(void**)&cuGraphicsUnregisterResource, "cuGraphicsUnregisterResource");
      bindFunc(cast(void**)&cuGraphicsSubResourceGetMappedArray, "cuGraphicsSubResourceGetMappedArray");
      bindFunc(cast(void**)&cuGraphicsResourceGetMappedMipmappedArray, "cuGraphicsResourceGetMappedMipmappedArray");
      bindFunc(cast(void**)&cuGraphicsResourceGetMappedPointer, "cuGraphicsResourceGetMappedPointer");
      bindFunc(cast(void**)&cuGraphicsResourceSetMapFlags, "cuGraphicsResourceSetMapFlags");
      bindFunc(cast(void**)&cuGraphicsMapResources, "cuGraphicsMapResources");
      bindFunc(cast(void**)&cuGraphicsUnmapResources, "cuGraphicsUnmapResources");
      bindFunc(cast(void**)&cuGetExportTable, "cuGetExportTable");
      bindFunc(cast(void**)&cuTexRefSetAddress2D_v2, "cuTexRefSetAddress2D_v2");
    }
  }

  public
  {
    this()
    {
      super(libNames);
    }
  }
}


__gshared DerelictCUDADriverLoader DerelictCUDADriver;

shared static this()
{
  DerelictCUDADriver = new DerelictCUDADriverLoader();
}
